//--------------------------------------------------------------------------------------//
//----------------------------------------abclib----------------------------------------//
//
//-------------------------FAUST CODE AND UTILITIES FOR MIXED MUSIC---------------------//
//
//-----------------------BY ALAIN BONARDI & PAUL GOUTMANN - 2019-2022 ------------------//
//---------------------CICM - MUSIDANSE LABORATORY - PARIS 8 UNIVERSITY-----------------//
//--------------------------------------------------------------------------------------//
//
declare author "Alain Bonardi & Paul Goutmann";
declare licence "LGPLv3";
declare name "abclib";
declare copyright "2019-2024 Bonardi, Goutmann CICM, U. Paris 8";
//
import("stdfaust.lib");
//provisional import of functions in hoa2.lib that will be migrated later to the official hoa.lib
import("hoa2.lib");
//provisional import of functions in mm.lib that will be later migrated to the official mm.lib
import("mm.lib");
//
//
//THE ABCLIB LIBRARY INCLUDES 2 TYPES OF FUNCTIONS
//- WITH THEIR CONTROL INTERFACE: _ui suffix in the name of the function (to refer to the idea of an object as in Max or PureData)
//- WITHOUT ANY CONTROL INTERFACE: no suffix in the name of the function
//
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//					AMBISONIC BASIC FUNCTIONS AND PROCESSES (SYN, FX)
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//
//--------------------------------------------------------------------------------------//
//AMBISONIC DECODERS: STEREO AND IRREGULAR (general decoder includes both modes)
//--------------------------------------------------------------------------------------//
//
//-------`(abc.)abc_2d_stereodecoder_ui`----------
// UI function for the stereo ambisonic decoder
//
// #### Usage
//
// ```
// _,_, ... : abc_2d_stereodecoder_ui(N) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
//-----------------------------
abc_2d_stereodecoder_ui(N) = thisStereoDecoder
	with {
			direct = 2 * nentry("v:decoderStereo2/directangles", 0, 0, 1, 1) - 1;
			gain = hslider("v:decoderStereo2/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
			leftDispatcher = _<:(*(1-direct), *(direct));
			rightDispatcher = _<:(*(direct), *(1-direct));
			thisStereoDecoder = ho.decoderStereo(N) : (*(gain), *(gain)) : (leftDispatcher, rightDispatcher) :> (_, _);
};

//-------`(abc.)abc_2d_decoder_ui`----------
// UI function for the general irregular decoder
//
// #### Usage
//
// ```
// _,_, ... : abc_2d_decoder_ui(N, P) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `P`: the number of loudspeakers (constant numerical expression)
//-----------------------------
abc_2d_decoder_ui(N, P) = iDecoder(N, la, direct, offset, stereo, gain) 
	with {
			direct = (2 * nentry("h:decoder/v:general/[0]directangles", 0, 0, 1, 1) - 1) : si.smoo; 
			offset = hslider("h:decoder/v:general/[1]angularoffset[unit:deg]", 0, -180, 180, 1) : si.smoo;
			gain = hslider("h:decoder/v:general/[3]gain[unit:dB]", 0, -127, 18, 0.01) : db2gain;
			stereo = nentry("h:decoder/v:general/[4]stereo", 0, 0, 1, 1) : si.smoo;
			//the angle of the the ith loudspeaker among nls loudspeakers, expressed in degrees for the end-user
			a(i, nls) = nentry("h:decoder/v:angles/a%i [unit:deg]", i * 360 / nls, -360, 360, 1);
			//la = list of angles//
 			la = par(i, P, a(i, P));
};

//-------`(abc.)abc_3d_decoder_ui`----------
// UI function for the general regular 3D decoder
//
// #### Usage
//
// ```
// _,_, ... : abc_3d_decoder_ui(N, P) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `P`: the number of loudspeakers (constant numerical expression)
//-----------------------------
abc_3d_decoder_ui(N, P) = decoder3D(N, la, le) 
	with {
			//the azimut of the the ith loudspeaker among nls loudspeakers, expressed in degrees for the end-user
			a(i, nls) = nentry("h:decoder/v:azimut/a%i [unit:deg]", i * 360 / nls, -360, 360, 1);
            //the elevation of the the ith loudspeaker among nls loudspeakers, expressed in degrees for the end-user
			e(i, nls) = nentry("h:decoder/v:elevation/e%i [unit:deg]", i * 180 / nls, 0, 180, 1);
			//la = list of angles//
 			la = par(i, P, a(i, P));
            le = par(i, P, e(i, P));
};
//
//--------------------------------------------------------------------------------------//
//AMBISONIC ENCODERS WITH ROTATION OR STATIC MODES
//--------------------------------------------------------------------------------------//
//
abc_2d_encoder_ui(N) = ho.rEncoder(N, speed, angle, returntime)
	with {
			speed = hslider("v:encoder/speed [unit:s-1]", 0, -100, 100, 0.001);
			angle = hslider("v:encoder/angle [unit:deg]", 0, -360, 360, 0.01) * ma.PI / 180.0 ;
			returntime = hslider("v:encoder/returntime [unit:msec]", 20, 0, 1000, 1) * 0.001;
};

abc_3d_encoder_ui(N) = ho.rEncoder3D(N, speedazim, speedelev, azim, elev, returntime)
	with {
			speedazim = hslider("v:encoder/speedazim [unit:s-1]", 0, -100, 100, 0.001);
            speedelev = hslider("v:encoder/speedelev [unit:s-1]", 0, -100, 100, 0.001);
			azim = hslider("v:encoder/azim [unit:deg]", 0, -360, 360, 0.01) * ma.PI / 180.0 ;
            elev = hslider("v:encoder/elev [unit:deg]", 0, 0, 180, 0.01) * ma.PI / 180.0 ;
			returntime = hslider("v:encoder/returntime [unit:msec]", 20, 0, 1000, 1) * 0.001;
};

//
//--------------------------------------------------------------------------------------//
//MULTIPLE AMBISONIC ENCODERS TO PLAY SEVERAL LOCALIZED SOURCES (STATIC ANGLES)
//--------------------------------------------------------------------------------------//
//
abc_2d_stereoEncoder_ui(N) = ho.stereoEncoder(N, angle)
	with {
			angle = hslider("v:stereoEncoder/angle [unit:deg]", 0, -360, 360, 0.01) * ma.PI / 180.0 : si.smoo;
};

abc_2d_multiEncoder_ui(N, ns) = ho.multiEncoder(N, ls, la, returntime)
	with {
			//the speed of the ith source among p sources, expressed in turns by second for the end user
			s(i, p) = nentry("v:multiencoder/h:speeds/s%i [unit:s-1]", 0, -100, 100, 0.001);
			//the angle of the ith source among p sources, expressed in degrees for the end-user
			a(i, p) = nentry("v:multiencoder/h:angles/a%i [unit:deg]", i * 360 / p, -360, 360, 0.01) * ma.PI / 180.0;
			//the interpolation time between static position and rotation
			returntime = hslider("v:multiencoder/returntime [unit:msec]", 20, 0, 1000, 1) * 0.001;
			//ls = list of speeds//
			ls = par(i, ns, s(i, ns));
			//la = list of angles//
 			la = par(i, ns, a(i, ns));
};

abc_3d_multiEncoder_ui(N, ns) = ho.multiEncoder3D(N, lAs, lEs, la, le, returntime)
	with {
			//the azimut speed of the ith source among p sources, expressed in turns by second for the end user
			sa(i, p) = nentry("v:multiencoder/h:speeds/sa%i [unit:s-1]", 0, -100, 100, 0.001);
			//the elevation speed of the ith source among p sources, expressed in turns by second for the end user
			se(i, p) = nentry("v:multiencoder/h:speeds/se%i [unit:s-1]", 0, -100, 100, 0.001);
			//the azimut of the ith source among p sources, expressed in degrees for the end-user
			a(i, p) = nentry("v:multiencoder/h:angles/a%i [unit:deg]", i * 360 / p, -360, 360, 0.01) * ma.PI / 180.0;
			//the elevation of the ith source among p sources, expressed in degrees for the end-user
			e(i, p) = nentry("v:multiencoder/h:angles/e%i [unit:deg]", i * 180 / p, -180, 180, 0.01) * ma.PI / 180.0;
			//the interpolation time between static position and rotation
			returntime = hslider("v:multiencoder/returntime [unit:msec]", 20, 0, 1000, 1) * 0.001;
			//ls = list of azimut speeds//
			lAs = par(i, ns, sa(i, ns));
			//ls = list of elevation speeds//
			lEs = par(i, ns, se(i, ns));
			//la = list of azimut//
 			la = par(i, ns, a(i, ns));
			//la = list of elevation//
 			le = par(i, ns, e(i, ns));
};

//
//--------------------------------------------------------------------------------------//
//2D MAPS : ONE SOURCE OR MULTISOURCE
//--------------------------------------------------------------------------------------//
//
abc_2d_map_ui(N) = thisMap
	with {
		thisMap(x, r, a) = ho.map(N, x, r, a);
};

abc_2d_multiMap_ui(N, ns) = par(i, ns, abc_2d_map_ui(N)) :> si.bus(2*N+1);
//
//--------------------------------------------------------------------------------------//
//AMBISONIC MIRROR WITH FACTOR
//--------------------------------------------------------------------------------------//
//
//FX MIRROR APPLIES A FACTOR AS A WEIGHT TO THE NEGATIVE HARMONICS
//TO CREATE THE MIRROR SOUNDFIELD TO ITSELF
//
//H					WEIGHT
//0					1				
//-1				FACTOR				
//1					1				
//-2				FACTOR				
//2					1				
//...
//-(N-1)			FACTOR
//(N-1)				1			
//-N				FACTOR
//N					1				
//
//THE FACTOR CAN TAKE 3 VALUES:
//1 => ORIGINAL SOUND FIELD
//0 => ORIGINAL + MIRROR SOUND FIELD
//-1 => MIRROR SOUND FIELD
//--------------------------------------------------------------------------------------//
abc_2d_mirror_ui(N) = ho.mirror(N, factor)
		with {
			factor = hslider("factor", 1, -1, 1, 1) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//ANALYSIS FUNCTION TO COMPUTE VECTOR VELOCITY & ENERGY COORDINATES
//--------------------------------------------------------------------------------------//
//
//
abc_2d_vectors_ui(nls) = vectorVE(laz) 
	with {
			//the angle of the the ith loudspeaker among nls loudspeakers, expressed in degrees for the end-user
			a(i, nls) = nentry("h:vectorVE/v:angles/a%i [unit:deg]", i * 360 / nls, -360, 360, 1);
			//la = list of angles//
 			laz = par(i, nls, a(i, nls));
};
//
abc_3d_vectors_ui(nls) = vectorVE3D(laz, lel) 
	with {
			//the angle of the the ith loudspeaker among nls loudspeakers, expressed in degrees for the end-user
			a(i, nls) = nentry("h:vectorVE3D/v:azimuth/a%i [unit:deg]", i * 360 / nls, -360, 360, 1);
            e(i, nls) = nentry("h:vectorVE3D/v:elev/e%i [unit:deg]", i * 90 / nls, -90, 90, 1);
			//laz = list of azimuth//
            //lel = list of elevation//
            laz = par(i, nls, a(i, nls));
            lel = par(i, nls, e(i, nls));
};
//
//--------------------------------------------------------------------------------------//
//AMBISONIC OPTIMIZATION WITH OPTIM TYPE
//--------------------------------------------------------------------------------------//
//
//A COMBINED OPTIMIZATION FUNCTION ENABLING THREE MODES OF OPTIMIZATION:
//-basic
//-maxRe
//-inPhase
//----------------`optimBasic`-------------------------
//The basic optimization has no effect and should be used for a perfect 
//circle of loudspeakers with one listener at the perfect center loudspeakers 
//array.
//----------------`optimMaxRe`-------------------------
//The maxRe optimization optimize energy vector. It should be used for an 
//auditory confined in the center of the loudspeakers array.
//----------------`optimInPhase`-------------------------
//The inPhase Optimization optimize energy vector and put all loudspeakers signals 
//in phase. It should be used for an auditory.
//--------------------------------------------------------------------------------------//
abc_2d_optim_ui(N) = ho.optim(N, optimtype)
		with {
			optimtype = nentry("optimtype", 0, 0, 2, 1);
};

abc_3d_optim_ui(N) = ho.optim3D(N, optimtype)
		with {
			optimtype = nentry("optimtype", 0, 0, 2, 1);
};
//
//--------------------------------------------------------------------------------------//
//AMBISONIC SOUND FIELD ROTATION
//--------------------------------------------------------------------------------------//
//
abc_2d_rotate_ui(N) = thisRotate
		with {
			rotfreq = hslider("v:rotate/speed [unit:s-1]", 0, -100, 100, 0.001);
			rotphase = hslider("v:rotate/angle [unit:deg]", 0, -360, 360, 0.01) / 360;
			returntime = hslider("v:rotate/returntime [unit:msec]", 20, 0, 1000, 1) * 0.001;
			//
			thisRotate =  ho.rotate(N, 2 * ma.PI * abc_rotationorstaticphase(rotfreq, rotphase, returntime));
};
//
//--------------------------------------------------------------------------------------//
//AMBISONIC SOUND FIELD ROTATION
//--------------------------------------------------------------------------------------//
//
abc_2d_wider_ui(N) = ho.wider(N, width)
		with {
			width = hslider("width", 0, 0, 1, 0.01) : si. smoo;
};
//
//--------------------------------------------------------------------------------------//
//SCOPE OBJECTS FOR AMBISONIC VIZUALISATION USING XY SCOPE OBJECTS
//--------------------------------------------------------------------------------------//
//
abc_2d_scope_ui(N) = ho.scope(N, refresh)
		with {
			//refresh time, default is 10 msec
			refresh = hslider("v:scope/refresh [unit:msec]", 10, 1, 2000, 1) * 0.001;
};


//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//2D SPATIAL TRAJECTORIES
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//2D SQUARE TRAJECTORY
//--------------------------------------------------------------------------------------//
//
abc_2d_squareTrajectory_ui = xySquare(freq, size)
		with {
			freq = hslider("v:trajectory/freq [unit:s-1]", 1, -1000., 1000., 0.01) : si.smoo;
			size = hslider("v:trajectory/size", 1, 0, 5, 0.01) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//2D Z TRAJECTORY
//--------------------------------------------------------------------------------------//
//
abc_2d_zTrajectory_ui = xyDoubleTriangle(freq, size)
		with {
			freq = hslider("v:trajectory/freq [unit:s-1]", 1, -1000., 1000., 0.01) : si.smoo;
			size = hslider("v:trajectory/size", 1, 0, 5, 0.01) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//2D RANDOM TRAJECTORY
//--------------------------------------------------------------------------------------//
//
abc_2d_randomTrajectory_ui = xyRandom(freq, size)
		with {
			freq = hslider("v:trajectory/freq [unit:s-1]", 1, -1000., 1000., 0.01) : si.smoo;
			size = hslider("v:trajectory/size", 1, 0, 5, 0.01) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//2D SQUARE AND Z TRAJECTORIES
//--------------------------------------------------------------------------------------//
//
abc_2d_squareAndZTrajectory_ui = xySquareDoubleTriangle(freq, size, crossfade)
		with {
			freq = hslider("v:trajectory/freq [unit:s-1]", 1, -1000., 1000., 0.01) : si.smoo;
			size = hslider("v:trajectory/size", 1, 0, 5, 0.01) : si.smoo;
			crossfade = hslider("v:trajectory/crossfade", 0, 0, 1, 0.01) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//POLAR VARIABLE CIRCLE TRAJECTORIES
//--------------------------------------------------------------------------------------//
//
abc_2d_polarVariableCircle_ui = polarVariableCircle(ampRho, freqRho, ampTheta, freqTheta, rotSpeed)
		with {
			ampRho = hslider("v:trajectory/ampRho", 0, 0, 1, 0.001);
			freqRho = hslider("v:trajectory/freqRho [unit:Hz]", 0, 0, 1000, 0.001);
			ampTheta = hslider("v:trajectory/ampTheta", 0, 0, 100, 0.001);
			freqTheta = hslider("v:trajectory/freqTheta [unit:Hz]", 0, 0, 1000, 0.001);
			rotSpeed = hslider("v:trajectory/rotSpeed [unit:t.s-1]", 0, -100, 100, 0.001);
};
//
//--------------------------------------------------------------------------------------//
//SYN AND FX DECORRELATION PROCESSES
//--------------------------------------------------------------------------------------//
//
//SYN DECORRELATION GENERATES SPATIAL DECORRELATED COMPONENTS IN AMBISONICS FROM ONE MONO SIGNAL
//FX DELAY APPLIES DECORRELATIONS TO SPATIAL COMPONENTS ALREADY CREATED
//THE DECORRELATION IS DEFINED FOR EACH SPATIAL COMPONENT AMONG P=2*N+1 AT THE AMBISONIC ORDER N
//AS A DELAY OF 0 IF FACTOR IS UNDER A CERTAIN VALUE 1-(i+1)/P AND DELAY*F((i+1)/P) IN THE CONTRARY CASE
//THE USER CAN CHOOSE THE TYPE OF DELAY TIME DISTRIBUTION AMONG 22 DIFFERENT DISTRIBUTIONS
//AS IN SYN OR FX DELAY THE DELAY INCREASES ACCORDING TO THE INDEX OF COMPONENTS
//BUT IT INCREASES AT EACH STEP AND IT IS MODULATED BY A THRESHOLD
//THEREFORE DELAYS ARE PROGRESSIVELY REVEALED WHEN THE FACTOR INCREASES
//WHEN THE FACTOR IS CLOSE TO 0, ONLY UPPER COMPONENTS ARE DELAYED
//WHEN THE FACTOR INCREASES, MORE AND MORE COMPONENTS ARE DELAYED
//FOR SYN DECORRELATION : 
//WHEN THE FACTOR IS BETWEEN [0, 1 / P] UPPER HARMONICS ARE PROGRESSIVELY FADED AND THE LEVEL OF THE H0 COMPONENT IS COMPENSATED
//TO AVOID SOURCE LOCALIZATION AND TO PRODUCE A LARGE MONO
//
//H					THRESHOLD			DELAY
//0					1-1/P				0 OR DELAY*F(1/P)
//-1				1-2/P				0 OR DELAY*F(2/P)
//1					1-3/P				0 OR DELAY*F(3/P)
//-2				1-4/P				0 OR DELAY*F(4/P)
//2					1-5/P				0 OR DELAY*F(5/P)
//...
//-(N-1)			1-(P-3)/P			0 OR DELAY*F((P-3)/P)
//(N-1)				1-(P-2)/P			0 OR DELAY*F((P-2)/P)
//-N				1-(P-1)/P			0 OR DELAY*F((P-1)/P)
//N					1-P/P				0 OR DELAY*F(P/P)
//
//THE PURPOSE IS TO EXPLORE TEMPORAL DECORRELATION BETWEEN SPATIAL COMPONENTS
//EITHER BY CREATING P DELAYED COPIES OF THE INCOMING SIGNAL (SYN DELAY)
//OR BY ADDING DELAYS TO THE ALREADY EXISTING P SPATIAL COMPONENTS
//
//--------------------------------------------------------------------------------------//
//fx decorrelation process
//--------------------------------------------------------------------------------------//
abc_2d_fx_decorrelation_ui(N) = fxDecorrelation(N, delay, winfreq, factor, fdbk, functiontype) 
	with {
		delay = hslider("v:synfxdecorrelation/delay [unit:samples]", 48000, 10, 262144, 1);
		window = 10; //by default a window of 10 milliseconds for the interpolation of delays//
		winfreq = 1000. / window;
		factor = hslider("v:synfxdecorrelation/factor", 0, 0, 1, 0.001);
		fdbk = hslider("v:synfxdecorrelation/fdbk", 0, 0, 0.99, 0.001);
		functiontype = hslider("v:synfxdecorrelation/functiontype", 0, 0, 21, 1);
		//
};

//
//--------------------------------------------------------------------------------------//
//syn decorrelation process
//--------------------------------------------------------------------------------------//
//
abc_2d_syn_decorrelation_ui(N) = synDecorrelation(N, delay, winfreq, factor, fdbk, functiontype)
	with {
		delay = hslider("v:synfxdecorrelation/delay [unit:samples]", 48000, 10, 262144, 1);
		window = 10; //by default a window of 10 milliseconds for the interpolation of delays//
		winfreq = 1000. / window;
		factor = hslider("v:synfxdecorrelation/factor", 0, 0, 1, 0.001);
		fdbk = hslider("v:synfxdecorrelation/fdbk", 0, 0, 0.999, 0.001);
		functiontype = hslider("v:synfxdecorrelation/functiontype", 0, 0, 21, 1);
		//
};

//
//--------------------------------------------------------------------------------------//
//man decorrelation process thaught to be control with abc.dtd.ui in the Max distribution
//--------------------------------------------------------------------------------------//
//
abc_2d_man_decorrelation_ui(N) = thisManDecorrelation 
with {
        P = 2*N+1;
        fd(i) = hslider("v:synfxdelay/feedback%i", 0, 0, 1, 0.001) :  si.smoo;
		d(i) = hslider("v:synfxdelay/delay%i [unit:msec]", (i/P)*1000, 0, 1000, 0.01);
        winfreq = 1000. / 10;
        //ms to smpl//
        durToSamp(x) = int(x * 0.001 * ma.SR);
		//list of delays//
 		ld = par(i, P, durToSamp(d(i)));
        //list of feedbacks
        lf = par(i, P, fd(i));
        thisManDecorrelation = fxDelay(N, ld, winfreq, lf) : abc_2d_fx_gain_ui(N);
    };
//
//--------------------------------------------------------------------------------------//
//fx 3D decorrelation process
//--------------------------------------------------------------------------------------//
abc_3d_fx_decorrelation_ui(N) = fxDecorrelation3D(N, delay, winfreq, factor, fdbk, functiontype, distributionmode) 
	with {
		delay = hslider("v:synfxdecorrelation3d/delay [unit:samples]", 48000, 10, 262144, 1);
		window = 10; //by default a window of 10 milliseconds for the interpolation of delays//
		winfreq = 1000. / window;
		factor = hslider("v:synfxdecorrelation3d/factor", 0, 0, 1, 0.001);
		fdbk = hslider("v:synfxdecorrelation3d/fdbk", 0, 0, 0.99, 0.001);
		functiontype = hslider("v:synfxdecorrelation3d/functiontype", 0, 0, 21, 1);
        distributionmode = hslider("v:synfxdecorrelation3d/distributionmode", 0, 0, 2, 1);
		//
};

//
//--------------------------------------------------------------------------------------//
//syn 3D decorrelation process
//--------------------------------------------------------------------------------------//
abc_3d_syn_decorrelation_ui(N) = synDecorrelation3D(N, delay, winfreq, factor, fdbk, functiontype, distributionmode) 
	with {
		delay = hslider("v:synfxdecorrelation3d/delay [unit:samples]", 48000, 10, 262144, 1);
		window = 10; //by default a window of 10 milliseconds for the interpolation of delays//
		winfreq = 1000. / window;
		factor = hslider("v:synfxdecorrelation3d/factor", 0, 0, 1, 0.001);
		fdbk = hslider("v:synfxdecorrelation3d/fdbk", 0, 0, 0.99, 0.001);
		functiontype = hslider("v:synfxdecorrelation3d/functiontype", 0, 0, 21, 1);
        distributionmode = hslider("v:synfxdecorrelation3d/distributionmode", 0, 0, 2, 1);
		//
};
//
//--------------------------------------------------------------------------------------//
//SYN AND FX DELAY PROCESSES
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//SYN DELAY GENERATES SPATIAL DELAYED COMPONENTS IN AMBISONICS FROM ONE MONO SIGNAL
//FX DELAY APPLIES DELAYS TO SPATIAL COMPONENTS ALREADY CREATED
//THE 2*N+1 DELAYS ARE EQUALLY SPREAD BETWEEN DELTIME/(N+1) AND DELTIME WHICH IS THE MAXIMUM
//H0 HAS A DELAY OF DELTIME/N, H-1 AND H1 OF 2*DELTIME/N, ETC.
//
//H					DELAY
//0					DELTIME/(N+1)
//-1 & 1			2*DELTIME/(N+1)
//-2 & 2			3*DELTIME/(N+1)
//-3 & 3			4*DELTIME/(N+1)
//...
//-(N-1)& (N-1)		N*DELTIME/(N+1)
//-N & N			DELTIME	
//
//THE PURPOSE IS TO EXPLORE TEMPORAL DECORRELATION BETWEEN SPATIAL COMPONENTS
//EITHER BY CREATING P DELAYED COPIES OF THE INCOMING SIGNAL (SYN DELAY)
//OR BY ADDING DELAYS TO THE ALREADY EXISTING P SPATIAL COMPONENTS
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//fx delay process
//--------------------------------------------------------------------------------------//
//
abc_2d_fx_delay_ui(n) = thisfxdelay
	with {
		window = hslider("v:synfxdelay/window [unit:msec]", 400, 10, 1000, 1);
		winfreq = 1000. / window;
		deltime = hslider("v:synfxdelay/deltime [unit:msec]", 100, 2, 10000, 0.01);
		feedback = hslider("v:synfxdelay/feedback", 0, 0, 1, 0.001) :  si.smoo;
		//
		durToSamp(d, i, p) = d * 2 / (p+1) * (1 + int((i+1)/2)) * 0.001 * ma.SR;
		//
		thisfxdelay = par(i, n, fdOverlappedDoubleDelay(durToSamp(deltime, i, n), 524288, winfreq, feedback));
};

//
//--------------------------------------------------------------------------------------//
//syn delay process
//--------------------------------------------------------------------------------------//
//
abc_2d_syn_delay_ui(n) = _ <: si.bus(n) : abc_2d_fx_delay_ui(n);

//
//--------------------------------------------------------------------------------------//
//SYN AND FX GRAIN PROCESSES
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//SYN GRAIN GENERATES SPATIAL GRANULAR COMPONENTS IN AMBISONICS FROM ONE MONO SIGNAL
//FX DELAY APPLIES GRANULAR TRANSFORMATION TO SPATIAL COMPONENTS ALREADY CREATED
//AT AMBISONIC ORDER N, THERE ARE 2*N+1 GRANULATORS, BEING TEMPORALLY CONTROLLED
//BY 2 PARAMETERS: THE GRAIN SIZE GS AND THE MAX DELAY D
//WE HAVE THE FOLLOWING DISPATCHING
//H					GRAINSIZE				MAXDELAY
//0					GS						0
//-1 & 1			GS - GS/(N+1)			D/(N+1)
//-2 & 2			GS - GS*2/(N+1)			2*D/(N+1)
//-3 & 3			GS - GS*3/(N+1)			3*D/(N+1)
//...
//-(N-1) & (N-1)	GS - GS*(N-1)/(N+1)		(N-1)*D/(N+1)
//-N & N			GS - GS*N/(N+1)			N*D/(N+1)
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//fx grain process
//--------------------------------------------------------------------------------------//
//
abc_2d_fx_grain_ui(n) = thisfxgrain
	with {
		grainsize = hslider("v:synfxgrain/grainsize [unit:msec]", 400, 2, 3000, 1);
		deltime = hslider("v:synfxgrain/deltime [unit:msec]", 100, 2, 5000, 0.01);
		feedback = hslider("v:synfxgrain/feedback", 0, 0, 1, 0.001) :  si.smoo;
		rarefaction = hslider("v:synfxgrain/rarefaction", 0.5, 0, 1, 0.001);
		//
		dur(d, i, p) = d * 2 / (p+1) * (int((i+1)/2)); //max delays in milliseconds for each spatial component
		gsize(gs, i, p) = gs - int((i+1) / 2) * gs * 2 / (p+1); //grain sizes in milliseconds for each spatial component
		thisfxgrain = (no.multinoise(2*n), si.bus(n)) : ro.interleave(n, 3) : par(i, n, granulator(gsize(grainsize, i, n), dur(deltime, i, n), rarefaction, feedback));
};

//
//--------------------------------------------------------------------------------------//
//syn grain process
//--------------------------------------------------------------------------------------//
//
abc_2d_syn_grain_ui(n) = thissyngrain
	with {
		grainsize = hslider("v:synfxgrain/grainsize [unit:msec]", 400, 2, 3000, 1);
		deltime = hslider("v:synfxgrain/deltime [unit:msec]", 100, 2, 5000, 0.01);
		feedback = hslider("v:synfxgrain/feedback", 0, 0, 1, 0.001) :  si.smoo;
		rarefaction = hslider("v:synfxgrain/rarefaction", 0.5, 0, 1, 0.001);
		//
		dur(d, i, p) = d * 2 / (p+1) * (int((i+1)/2)); //max delays in milliseconds for each spatial component
		gsize(gs, i, p) = gs - int((i+1) / 2) * gs * 2 / (p+1); //grain sizes in milliseconds for each spatial component
		thissyngrain = (no.multinoise(2*n), (_ <: si.bus(n))) : ro.interleave(n, 3)  : par(i, n, granulator(gsize(grainsize, i, n), dur(deltime, i, n), rarefaction, feedback));
};

//
//
//--------------------------------------------------------------------------------------//
//SYN AND FX RINGMODULATION PROCESSES
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//SYN RINGMOD GENERATES SPATIAL COMPONENTS IN AMBISONICS FROM ONE MONO SIGNAL THANKS TO RING MODULATION
//FX RINGMOD APPLIES RING MODULATION TO SPATIAL COMPONENTS ALREADY CREATED
//THE RING MODULATION IS DEFINED FOR EACH SPATIAL COMPONENT AMONG P=2*N+1 AT THE AMBISONIC ORDER N
//FOR EACH SPATIAL COMPONENT #i, THE RESULT IS EITHER THE ORIGINAL SIGNAL OR A RING MODULATED SIGNAL
//ACCORDING TO A THRESHOLD WHICH IS i/P.
//THE GENERAL PROCESS IS DRIVEN BY A FACTOR BETWEEN 0 AND 1 AND A MODULATION FREQUENCY F0
//IF FACTOR IS GREATER THAN THRESHOLD (P-i-1)/P, THE ith RING MODULATOR IS ON WITH CARRIER OF F0*(i+1)/P
//IN THE CONTRARY IT PROVIDES THE ORIGINAL SIGNAL
//THEREFORE RING MODULATORS ARE PROGRESSIVELY REVEALED WHEN THE FACTOR INCREASES
//
//H					THRESHOLD			    OUTPUT
//0					(P-1)/P					ORIGINAL OR RING MODULATION BY F0*1/P
//-1				(P-2)/P					ORIGINAL OR RING MODULATION BY F0*2/P
//1					(P-3)/P			        ORIGINAL OR RING MODULATION BY F0*3/P
//-2				(P-4)/P			        ORIGINAL OR RING MODULATION BY F0*4/P
//2					(P-5)/P			        ORIGINAL OR RING MODULATION BY F0*5/P
//...
//-(N-1)			3/P				        ORIGINAL OR RING MODULATION BY F0*(P-3)/P
//(N-1)				2/P				        ORIGINAL OR RING MODULATION BY F0*(P-2)/P
//-N				1/P				        ORIGINAL OR RING MODULATION BY F0*(P-1)/P
//N					0				        ORIGINAL OR RING MODULATION BY F0*P/P=F0
//
//--------------------------------------------------------------------------------------//
//
//--------------------------------------------------------------------------------------//
//fx ringmod process
//--------------------------------------------------------------------------------------//
//
abc_2d_fx_ringmod_ui(N) = ho.fxRingMod(N, f0, factor, functiontype)
	with {
		f0 = hslider("v:fxringmod/f0 [unit:Hz]", 10, 0, 10000, 0.0001);
		factor = hslider("v:fxringmod/factor", 0, 0, 1, 0.001);
		functiontype = hslider("v:fxringmod/functiontype", 0, 0, 21, 1);
};

//
//--------------------------------------------------------------------------------------//
//syn ringmod process
//--------------------------------------------------------------------------------------//
//
abc_2d_syn_ringmod_ui(N) = ho.synRingMod(N, f0, factor, functiontype)
	with {
		f0 = hslider("v:synfxringmod/f0 [unit:Hz]", 10, 0, 10000, 0.0001);
		factor = hslider("v:synfxringmod/factor", 0, 0, 1, 0.001);
		functiontype = hslider("v:synfxringmod/functiontype", 0, 0, 21, 1);
};

//
//--------------------------------------------------------------------------------------//
//fx 3D ringmod process
//--------------------------------------------------------------------------------------//
//
abc_3d_fx_ringmod_ui(N) = fxRingMod3D(N, f0, factor, functiontype, distributionmode)
	with {
		f0 = hslider("v:synfxringmod3d/f0 [unit:Hz]", 10, 0, 10000, 0.0001);
		factor = hslider("v:synfxringmod3d/factor", 0, 0, 1, 0.001);
		functiontype = hslider("v:synfxringmod3d/functiontype", 0, 0, 21, 1);
        distributionmode = hslider("v:synfxringmod3d/distributionmode", 0, 0, 2, 1);
};

//
//--------------------------------------------------------------------------------------//
//syn 3D ringmod process
//--------------------------------------------------------------------------------------//
//
abc_3d_syn_ringmod_ui(N) = synRingMod3D(N, f0, factor, functiontype, distributionmode)
	with {
		f0 = hslider("v:synfxringmod3d/f0 [unit:Hz]", 10, 0, 10000, 0.0001);
		factor = hslider("v:synfxringmod3d/factor", 0, 0, 1, 0.001);
		functiontype = hslider("v:synfxringmod3d/functiontype", 0, 0, 21, 1);
        distributionmode = hslider("v:synfxringmod3d/distributionmode", 0, 0, 2, 1);
};

//
//--------------------------------------------------------------------------------------//
//fx 2D gain process 
//--------------------------------------------------------------------------------------//
//
abc_2d_fx_gain_ui(N) = fxGain(N, lg)
    with {
        P = 2*N+1;
        gain(i) = hslider("v:synfxgain/gain%i", 0., 0., 1., 0.0001);
        //list of gains
        lg = par(i, P, gain(i));
	};

//
//--------------------------------------------------------------------------------------//
//syn 2D gain process 
//--------------------------------------------------------------------------------------//
//
abc_2d_syn_gain_ui(N) = synGain(N, lg)
    with {
        P = 2*N+1;
        gain(i) = hslider("v:synfxgain/gain%i", 0., 0., 1., 0.0001);
        //list of gains
        lg = par(i, P, gain(i));
	};

//
//
//--------------------------------------------------------------------------------------//
// VBAP spatialization
//--------------------------------------------------------------------------------------//
// la = list of angles of the loudspeakers (in degrees)
// theta  = angle of the virtual source (in degrees)
abc_2d_vbap_ui(n) = circularScaledVBAP(la, theta)
	with {
		a(i, nls) = nentry("v:vbap/a%i [unit:deg]", i * 360 / nls, -360, 360, 1);
		theta = nentry("v:vbap/theta [unit:deg]", 0, -360, 360, 0.01);
		//la = list of angles//
 		la = par(i, n, a(i, n));
	};
//
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//MULTICHANNEL SYNTHESIS
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//
//--------------------------------------------------------------------------------------//
//ADDITIVE SYNTHESIS
//--------------------------------------------------------------------------------------//
//
abc_addSynth_ui(n) = thisAdditiveSynth
			with {
				//fundamental frequency//
				f0 = nentry("v:addSynth/f0 [unit:Hz]", 220, 0.01, 15000, 0.01);
				//general gain//
				gain = hslider("v:addSynth/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
				//amplitude of each partial
				amp(ind) = hslider("v:addSynth/h:partials/v:amps/amp%ind", (ba.linear2db(1/(ind+1))), -127, 18, 0.01) : db2gain;
				//frequency multipliers (harmonic by default :f, 2*f, 3*f, etc.))//
				fmult(ind) = nentry("v:addSynth/h:partials/v:fmults/fmult%ind", (ind+1), 0, 1000, 0.00001);
				//beats - second oscillator shifted of a few Hz (by default 0)
				fbeat(ind) = nentry("v:addSynth/h:partials/v:fbeats/fbeat%ind [unit:Hz]", 0, 0, 20, 0.01);
				//
				thisAdditiveSynth = par(i, n, doubleOscillator(f0, fmult(i), fbeat(i)) : *(amp(i)) : *(gain));
};

//
//--------------------------------------------------------------------------------------//
//SUBSTRACTIVE SYNTHESIS
//--------------------------------------------------------------------------------------//
//
abc_substractSynth_ui(n) = thisSubstractiveSynth
			with {		
				//fundamental frequency//
				f0 = hslider("v:substractSynth/f0 [unit:Hz]", 220, 0.01, 15000, 0.01);
				//general gain
				gain = hslider("v:substractSynth/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
				//filter factor of quality
				filterQ = hslider("v:substractSynth/filterQ", 50, 1, 500, 1);
				//filter gain
				filterG = hslider("v:substractSynth/filterG", 0.8, 0, 1, 0.01);
				//amplitude of each partial
				amp(ind) = hslider("v:substractSynth/h:partials/v:amps/amp%ind", (ba.linear2db(1/(ind+1))), -127, 18, 0.01) : db2gain;
				//frequency multipliers (harmonic by default :f, 2*f, 3*f, etc.))//
				fmult(ind) = nentry("v:substractSynth/h:partials/v:fmults/fmult%ind", (ind+1), 0, 1000, 0.00001);
				//
				thisSubstractiveSynth = par(i, n, fi.resonbp(f0 * fmult(i), filterQ, filterG) : *(amp(i)) : *(gain)) ;
};

//
//--------------------------------------------------------------------------------------//
//AUDIOTESTER
//--------------------------------------------------------------------------------------//
//
abc_audioTester_ui = audioTester(nls, nhpmax, freq, gain)
			with {
				nhpmax = 64; //maximum number of loudspeakers
				nls = nentry("v:audioTester/nls", 2, 1, nhpmax, 1); //number of loudspeakers used (from 1 to 64)
				freq = hslider("v:audioTester/freq", 1, 0.01, 100, 0.01);//frequency of the envelopes
				gain = hslider("v:audioTester/gain [unit:dB]", -20, -127, 18, 0.01) : db2gain;
};

//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//MULTICHANNEL PROCESSES
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//
//
//--------------------------------------------------------------------------------------//
//BUS SELECTOR (BUSSELECT)
//--------------------------------------------------------------------------------------//
//
abc_busselect_ui(n) = busSelector(n, ramp, leftOrRight)
			with {
				ramp = nentry("v:busselect/ramp [unit:msec]", 100, 0, 100000, 1) * ma.SR / 1000.0; //transition ramp duration in msec converted to samples//
				leftOrRight = nentry("v:busselect/leftOrRight", 0, 0, 1, 1); //selection between left and right buses
				thisbusselect = (par(i, n, *(1-leftOrRight)), par(i, n, *(leftOrRight))) :> si.bus(n);
};

abc_busplus_ui(n) = busPlus(n);

abc_busmult_ui(n) = busMult(n);

//
//with one input source (exception for one source)
abc_chowningPan1_ui = chowningPanner(incAngle, phi0) : (*(gain), *(gain))
			with {
				//phi0 is the half angle of the stereophony, between the left speaker and the front line of the listener//
				phi0 = hslider("v:chopan/phi0 [unit:deg]", 30, 1, 90, 1) : si.smoo;
				//incAngle is the incident angle of the source when there is only one (not applicable to several sources)
				incAngle = hslider("v:chopan/incAngle [unit:deg]", 0, -90, 90, 1) : si.smoo;
				gain = hslider("v:chopan/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
};
abc_chowningPan_ui(n) = multiChowningPanner(n, phi0, gain)
			with {
				//phi0 is the half angle of the stereophony, between the left speaker and the front line of the listener//
				phi0 = hslider("v:chopan/phi0 [unit:deg]", 30, 1, 90, 1) : si.smoo;
				//gain is the output gain in dB
				gain = hslider("v:chopan/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
};
//
//--------------------------------------------------------------------------------------//
//PARALLEL DELAYS
//--------------------------------------------------------------------------------------//
//
abc_pardelset_ui(n) = par(i, n, (pardel(i) : *(gain(i))))
			with {
					tempo = nentry("h:multidelays/v:general/tempo [unit:bpm]", 60, 1, 600, 0.01);
					dur(ind)=((hslider("h:multidelays/v:durations/dur%ind [unit:musicaldur]", 1, 0, 32, 0.0001) * 60 / tempo * ma.SR), Ndelsamp) : min;
					gain(ind) = hslider("h:multidelays/v:dynamics/gain%ind [unit:dB]", 0, -127, 18, 0.001) : db2gain;
					fdbk(ind) = hslider("h:multidelays/v:fdbks/fdbk%ind", 0, 0, 0.99999, 0.0001) : si.smoo;
					updatefreq = hslider("h:multidelays/v:general/updatefreq [unit:Hz]", 30, 0.0001, 1000, 0.0001);
					//
					pardel(ind) = fdOverlappedDoubleDelay(dur(ind), Ndelsamp, updatefreq, fdbk(ind));

			};
//
//--------------------------------------------------------------------------------------//
//DELAY CHAINS
//--------------------------------------------------------------------------------------//
//
abc_delaychain_ui(n) = thisdelaychain
			with {
				updatefreq = hslider("h:chaindelays/v:general/updatefreq [unit:Hz]", 30, 0.0001, 1000, 0.0001);
				fdbk = hslider("h:chaindelays/v:general/fdbk", 0, 0, 0.99999, 0.0001) : si.smoo;
				tempo = nentry("h:chaindelays/v:general/tempo [unit:bpm]", 60, 1, 600, 0.01);
				//
				dur(ind)=((nentry("h:multidelays/v:durations/dur%ind [unit:musicaldur]", 1, 0, 32, 0.0001) * 60 / tempo * ma.SR), Ndelsamp) : min ;
				gain(ind) = hslider("h:multidelays/v:dynamics/gain%ind [unit:dB]", 0, -127, 18, 0.001) : db2gain;
				delseq(ind) = overlappedDoubleDelay(dur(ind-1), Ndelsamp, updatefreq);
				//
				//--------------------------------------------------------------------------------------//
				//RECURSIVE DEFINITION OF A DELAY CHAIN WITH DELSEQ ELEMENTARY DELAYS
				//--------------------------------------------------------------------------------------//
				delaychain(1) = delseq(1);
				delaychain(2) = delseq(1) <: (delseq(2), _);
				delaychain(n) = delaychain(n-1) : ((_ <: (delseq(n), _)), si.bus(n-2));
				//
				thisdelaychain = (+ <: (delaychain(n), _) : (_, par(i, n, *(gain(n-i-1))))) ~ (*(fdbk)) : (!, ro.cross(n));
};
//
//--------------------------------------------------------------------------------------//
//MULTI FLANGERS
//--------------------------------------------------------------------------------------//
//
//
abc_multiflanger_ui(n) = decorrelatedFlangers(n, rate, depth, offset, fdbk, spread, Nflangersamp)
			with {
				rate = vslider("h:flanger/rate [unit:Hz]", 0.5, 0.01, 500, 0.001) : si.smoo;
				depth = vslider("h:flanger/depth [unit:msec]", 40, 0, 1000, 0.001) : si.smoo;
				offset = vslider("h:flanger/offset [unit:msec]", 10, 0, 200, 0.001) : si.smoo;
				fdbk = vslider("h:flanger/fdbk", 1, 0, 1, 0.001) : si.smoo;
				spread = vslider("h:flanger/spread", 0, 0, 1, 0.001) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//MULTI FREQUENCY SHIFTERS
//--------------------------------------------------------------------------------------//
//
abc_multifreqshift_ui(n) = par(i, n, (fshiftp(fr(i)) : *(gain(i))))
			with {
				//Shifting frequencies
				fr(ind) = hslider("h:multifreqshifts/v:shiftingfreqs/fr%ind [unit:Hz]", 0, -10000, 10000, 0.001);
				//Gains in dB
				gain(ind) = hslider("h:multifreqshifts/v:dynamics/gain%ind [unit:dB]", 0, -127, 18, 0.001) : db2gain;
				//
			};
//
//--------------------------------------------------------------------------------------//
//MULTI CHANNEL GAINS
//--------------------------------------------------------------------------------------//
//
abc_gainline(n, g) = par(i, n, *(g));
//
abc_multigain_ui(n) = abc_gainline(n, gain)
			with {
				gain = hslider("v:gains/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;

};
//
//--------------------------------------------------------------------------------------//
//MULTI GRANULATORS
//--------------------------------------------------------------------------------------//
//
abc_multigrain_ui(n) = (no.multinoise(2*n), si.bus(n)) : ro.interleave(n, 3) : par(i, n, granulator(gs(i), dt(i), rrf(i), fdbk(i)))
			with {
				gs(ind) = hslider("h:multigrains/v:grainsizes/gs%ind [unit:msec]", 400, 2, 3000, 1);
				dt(ind) = hslider("h:multigrains/v:delsmax/dt%ind [unit:msec]", 100, 2, 5000, 0.01);
				fdbk(ind) = hslider("h:multigrains/v:fdbks/fdbk%ind", 0, 0, 0.99999, 0.0001) : si.smoo;
				rrf(ind) = hslider("h:multigrains/v:rarefactions/rrf%ind", 0.5, 0, 1, 0.001);
			};
//
//--------------------------------------------------------------------------------------//
//MULTI HARMONIZERS
//--------------------------------------------------------------------------------------//
//
abc_multiharmo_ui(n) = par(ind, n, harmonizer(trans(ind), winsize(ind), gain(ind)))
			with {
				//amount of transposition (in midicents) of the harmonizer #i
				trans(ind) = hslider("h:multiharmo/v:transpositions/trans%ind [unit:midicents]", 0, -2400, 2400, 0.001);
				//gain in dB of the harmonizer #i
				gain(ind) = hslider("h:multiharmo/v:gains/gain%ind [unit:dB]", 0, -127, 18, 0.001) : db2gain;
				//window size of the harmonizer #i
				winsize(ind) = hslider("h:multiharmo/v:windowsizes/winsize%ind", 50, 0, 127, 0.001) : pdLineDrive4096;
			};
//
//--------------------------------------------------------------------------------------//
//MULTI NOISES
//--------------------------------------------------------------------------------------//
//
abc_multinoise_ui(n) = no.multinoise(n);
//
//--------------------------------------------------------------------------------------//
//MULTIPLE SHORTENING ENVELOPS
//--------------------------------------------------------------------------------------//
//
abc_multishorteningenv(n, f, s, d) = no.multinoise(n) : par(i, n, shorteningEnv(f, s, d * i / n));
//
//
//--------------------------------------------------------------------------------------//
//MULTIPLE SHORTENING ENVELOPS APPLIED TO N INPUT SIGNALS
//--------------------------------------------------------------------------------------//
//
abc_multishorteningenv_ui(n) = par(i, n, _), abc_multishorteningenv(n, freq, rarefaction, spread) : ro.interleave(n, 2) : par(i, n, *) 
			with {
				rarefaction = hslider("v:randenv/rarefaction", 0.5, 0, 1, 0.01) : si.smoo;
				freq = nentry("v:randenv/freq [unit:Hz]", 10, 0.01, 100, 0.01) : si.smoo;
				spread = hslider("v:randenv/spread", 0, 0, 1, 0.001) : si.smoo;
};
//
//--------------------------------------------------------------------------------------//
//MULTIPLE LINEAR RANDOM ENVELOPES
//--------------------------------------------------------------------------------------//
//
abc_multilinrandenv(n, f, s, d) = (no.multinoise(n), si.bus(n)) : ro.interleave(n, 2) : par(i, n, linRandEnv(f,s, d * i / n));
//
abc_multilinrandenv_ui(n) = abc_multilinrandenv(n, freq, rarefaction, spread)
			with {
				rarefaction = hslider("v:randenv/rarefaction", 0.5, 0, 1, 0.01) : si.smoo;
				freq = nentry("v:randenv/freq [unit:Hz]", 10, 0.01, 100, 0.01) : si.smoo;
				spread = hslider("v:randenv/spread", 0, 0, 1, 0.001) : si.smoo;
};
//
//
//--------------------------------------------------------------------------------------//
//MATRICES
//--------------------------------------------------------------------------------------//
//
abc_matrix_ui(n, m) = thismatrix
			with {
				ramp = nentry("h:matrix/ramp [unit:msec]", 100, 0, 100000, 1) * ma.SR / 1000.; //transition ramp duration in msec converted to samples//
				toggle(c, in) = nentry("h:matrix/v:Col%2c/m%in", 0, -1, 1, 0.001) : ba.line(ramp);
				mixer(n,out) 	= par(in, n, *(toggle(in, in+out*n)) ) :> _ ;
				thismatrix = par(in, n, _) <: par(out, m, mixer(n, out));
};

//
//
//
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//								MONO SYNTHESES OR PROCESSES
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//
//
//
//--------------------------------------------------------------------------------------//
//PEAKAMP ON N SAMPLES
//--------------------------------------------------------------------------------------//
//
abc_peakamp_ui = peakamp(nsamp)
		with {
			nsamp = int(hslider("v:peakamp/period [unit:msec]", 10, 1, 5000, 1) * ma.SR / 1000.);
		};
//
//--------------------------------------------------------------------------------------//
//SOUNDDETECTOR
//--------------------------------------------------------------------------------------//
//
abc_soundDetector_ui(x) = soundDetector(tSlice, offset, noiseFloor, noteOn, noteDur, offDur, attack, x)
		with {
			offset = nentry("v:Detector/h:calibration_dB/offset [unit:dB]", 10, -64, 64, 1) : si.smoo;
			noiseFloor = nentry("v:Detector/h:calibration_dB/noiseFloor [unit:dB]", -50, -120, 0, 1) : si.smoo;
			noteOn = nentry("v:Detector/h:calibration_dB/noteOn [unit:dB]", -60, -120, 0, 1) : si.smoo;
			attack = nentry("v:Detector/h:soundFollow/attack", 0, 0, 1, 1);
			tSlice = nentry("v:Detector/h:soundFollow/tSlice", 10, 1, 100, 1);
			noteDur = nentry("v:Detector/h:noteOnOff/noteDur [unit:msec]", 50, 1, 500, 1) : si.smoo;
			offDur = nentry("v:Detector/h:noteOnOff/offDur [unit:msec]", 25, 1, 500, 1) : si.smoo;
		};
//
abc_fullSoundDetector_ui = _ <:(offbeforeuse, abc_soundDetector_ui) : * <: (_, onetozero(delta), onetozerodec(delta))
	with {
		offbeforeuse = (_, abs) ~ (max) : (_, !) : (_ > 0);
		impulseinc = _ <: _, mem : - : (_ > 0.0);
		impulsedec = _ <: _, mem : - : (_ < 0.0);
		release(n) = + ~ (_ <: _, (_ > 0) / n : -);
		onetozero(n) = impulseinc : release(n) : min(1) : max(0);
		onetozerodec(n) = impulsedec : release(n) : min(1) : max(0);
		delta = 20 * ma.SR / 1000.; //20 msec impulsion for attack or release//
	};
//
//--------------------------------------------------------------------------------------//
//REV4 REVERBERATION
//--------------------------------------------------------------------------------------//
//
abc_rev4stereo_ui = rev4Stereo(revDur, revGain)
			with {
				//2 controls: revDur which is the duration of the reverb (127 is infinite)
				//revAmp is the amplitude of the output sound of the reverb
				revDur = hslider("v:rev4/revDur [unit:midiscale]", 120, 0, 127, 1) : /(254.) : si.smoo;
				revGain = hslider("v:rev4/revGain [unit:midiscale]", 100, 0, 127, 1) : basicLineDrive;
};
//
abc_rev4quadri_ui = rev4Quadri(revDur, revGain)
			with {
				//2 controls: revDur which is the duration of the reverb (127 is infinite)
				//revAmp is the amplitude of the output sound of the reverb
				revDur = hslider("v:rev4/revDur [unit:midiscale]", 120, 0, 127, 1) : /(254.) : si.smoo;
				revGain = hslider("v:rev4/revGain [unit:midiscale]", 100, 0, 127, 1) : basicLineDrive;
};
//
//--------------------------------------------------------------------------------------//
//RAINDROPS
//--------------------------------------------------------------------------------------//
//
abc_raindrops(df, dthi, af, att, q, g, l) = (variableFrequency, exciter) : (_, reson) : envelope : * <: output with {
	//
	//df is the frequency of appearance of drops
	//dthi is the thinness of the drops
	//af is the average frequency for the randomization of frequencies
	//att is the duration of the attack of the envelope
	//rel is the duration of the release of the envelope
	//
	//constants for freq randomization
	randomPeriodAmp = 2000; //in milliseconds
	//
	//reson filter gain
	fg = 0.05;//
	//
	//constants for the drop envelope
	releasedur = 0.1; //release duration, 100 milliseconds by default
	//
	//to calibrate the randomization of the frequency of the filter
	randomizedFrequencyCalibration = +(1) : *(0.5) : *(af) : +(af);
	//to calibrate the randomization of the duration between two successive frequency randomization
	randomizedDurationCalibration = +(1) : *(0.5) : *(randomPeriodAmp) : *(0.1) : +(1) : /(1000) : *(ma.SR) : int;
	//
	permutation(a,b) = (b, a);
	variablePulseAndDuration = ((ba.pulse <: (_, _), (no.noise : randomizedDurationCalibration)) : (_, ba.sAndH) : permutation) ~ (+(10)) : (!, _);
	variableFrequency = ((variablePulseAndDuration <: (_, _)), (no.noise : randomizedFrequencyCalibration)) : (_, ba.sAndH);
	reson(f) = fi.resonbp(f, q, 0.05);
	exciter = os.phasor(1, df) : *(-dthi) : +(1) : ampClip;
	envelope = (en.ar(att, releasedur), _) : (+(1), _);
	output = (co.limiter_1176_R4_mono, _) : (*(l), *(1-l)) : + : *(g);
};
//
abc_raindrops_ui = abc_raindrops(dropfreq, dropthinness, avgfreq, attackdur, qf, gain, limiter)
			with {
				//period of the drops
				dropperiod = hslider("v:drops/dropperiod", 1000, 1, 10000, 0.01);
				dropfreq = 1000. / dropperiod;
				//
				//quality factor of the reson filter
				qf = hslider("v:drops/qf", 50, 1, 1000, 1); //quality factor for the reson filter, 50 by default
				//
				//use of the limiter or not
				limiter = nentry("v:drops/limiter", 1, 0, 1, 1) : si.smoo;
				//
				//average randomized frequency
				avgfreq = hslider("v:drops/avgfreq", 1407, 50, 10000, 0.01);
				//
				//attack duration in milliseconds (then converted to seconds)
				//
				attackdur = hslider("v:drops/attackdur", 5, 1, 100, 1) / 1000 ; //attack duration, 5 milliseconds by default
				//
				//impulsion thinness
				//
				dropthinness = hslider("v:drops/dropthinness", 50, 0.01, 1000, 0.01); //must be > 0
				//
				gain = hslider("v:drops/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
};


//
//--------------------------------------------------------------------------------------//
//GENERATOR - NOISE / SINUS / PHASOR
//--------------------------------------------------------------------------------------//
//
abc_globalgenerator_ui = (noisegenerator, sinusgenerator, phasorgenerator) :> *(gain)
			with {
				gain = hslider("v:generator/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
				//
				//controls for the noise generator
				noiseonoff = checkbox("v:generator/h:noise/noiseon") : si.smoo;
				noisecutoff = hslider("v:generator/h:noise/noisecutoff [unit:Hz]", 1760, 20, 20000, 0.01);
				noisepulserate = hslider("v:generator/h:noise/noisepulserate [unit:Hz]", 3, 0.01, 20, 0.01) * 0.5;
				noisepulseratio = hslider("v:generator/h:noise/noisepulseratio", 1, 0, 10, 1);
				//
				//controls for the sinus generator
				sinusonoff = checkbox("v:generator/h:sinus/sinuson") : si.smoo;
				sinusfreq = hslider("v:generator/h:sinus/sinusfreq [unit:Hz]", 440, 20, 20000, 0.01);
				sinuspulserate = hslider("v:generator/h:sinus/sinuspulserate [unit:Hz]", 3, 0.01, 20, 0.01) * 0.5;
				sinuspulseratio = hslider("v:generator/h:sinus/sinuspulseratio", 1, 0, 10, 1);
				//
				//controls for the phasor generator
				phasoronoff = checkbox("v:generator/h:phasor/phasoron") : si.smoo;
				phasorfreq = hslider("v:generator/h:phasor/phasorfreq [unit:Hz]", 440, 20, 20000, 0.01);
				phasorpulserate = hslider("v:generator/h:phasor/phasorpulserate [unit:Hz]", 3, 0.01, 20, 0.01) * 0.5;
				phasorpulseratio = hslider("v:generator/h:phasor/phasorpulseratio", 1, 0, 10, 1);
				//
				//noise, sinus and phasor generators
				noisegenerator = (no.noise, pulsedEnv1(noisepulserate, noisepulseratio)) : * : *(noiseonoff) : fi.resonlp(noisecutoff, 5, 0.75);
				sinusgenerator = (os.osccos(sinusfreq), pulsedEnv1(sinuspulserate, sinuspulseratio)) : * : *(sinusonoff);
				phasorgenerator = (os.phasor(1, phasorfreq), pulsedEnv1(phasorpulserate, phasorpulseratio)) : * : *(phasoronoff);
};



//
//--------------------------------------------------------------------------------------//
//RISSET'S BELL
//--------------------------------------------------------------------------------------//
//
abc_rissetsbell_ui = (_, gate) : rissetsbell(dur, freq, pfreq2, resq, resg, osc2filter, gain)
			with {
				//
				//global parameters to control the features of the bell
				dur = hslider("v:rissetbell/dur [unit:msec]", 5000, 10, 600000, 1) / 1000;//global duration in milliseconds
				freq = hslider("v:rissetbell/freq [unit:Hz]", 440, 1, 10000, 0.01);
				pfreq2 = hslider("v:rissetbell/pfreq2", 1, 0, 10, 0.001) : si.smoo;
				//
				//global parameters to control the reson bandpass filters//
				resq = nentry("resq", 1000., 0., 1000., 0.1);//reson quality factor//
				resg = nentry("resg", 0.1, 0., 1., 0.01);//reson gain//
				//
				//global parameter between generation and filtering
				osc2filter = nentry("osc2filter", 0., 0., 1., 0.01) : si.smoo;
				//
				//global amplitude of the bell
				gain = hslider("v:decoder/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
				//
				//triggering of the bell
				gate = button("gate");
				//
};

//
//--------------------------------------------------------------------------------------//
//SOUND COAT
//--------------------------------------------------------------------------------------//
//
abc_soundcoat_ui = soundcoat(16, f0, randfreq, gain)
			with {
				f0 = nentry("v:synthetizers/f0 [unit:Hz]", 100, 20, 10000, 0.01);
				randwin= nentry("v:synthetizers/randwin [unit:msec]", 3000, 1, 20000, 1);
				randfreq = 1000. / randwin;
				gain = hslider("v:synthetizers/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
};


abc_jupiterbank_ui = jupiterOscFilterBank(f0, k, osc2filter, resq, resg, gain)
		with {
				f0 = hslider("v:jupiterbank/f0 [unit:Hz]", 440, 20, 20000, 0.001);
				k = hslider("v:jupiterbank/k", 1, 0.00001, 100, 0.00001);
				//global parameter between generation and filtering
				osc2filter = nentry("v:jupiterbank/osc2filter", 0., 0., 1., 0.01) : si.smoo;
				//global parameters to control the reson bandpass filters//
				resq = nentry("v:jupiterbank/resq", 1000., 0., 1000., 0.1);//reson quality factor//
				resg = nentry("v:jupiterbank/resg", 0.1, 0., 1., 0.01);//reson gain//
				//global amplitude of the bell
				gain = hslider("v:jupiterbank/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
};


abc_jupiterbank2_ui = jupiterOscFilterBank2(f0, k, fa, dt, osc2filter, resq, resg, gain)
		with {
				f0 = hslider("v:jupiterbank/f0 [unit:Hz]", 440, 20, 20000, 0.001);
				k = hslider("v:jupiterbank/k", 1.004, 0.00001, 100, 0.00001);
				fa = hslider("v:jupiterbank/fa", 1, 0.01, 100., 0.01) / 100.;
				dt = int(hslider("v:jupiterbank/dt [unit:msec]", 100, 1, 10000, 1) * ma.SR / 1000.);
				//global parameter between generation and filtering
				osc2filter = nentry("v:jupiterbank/osc2filter", 0., 0., 1., 0.01) : si.smoo;
				//global parameters to control the reson bandpass filters//
				resq = nentry("v:jupiterbank/resq", 1000., 0., 1000., 0.1);//reson quality factor//
				resg = nentry("v:jupiterbank/resg", 0.1, 0., 1., 0.01);//reson gain//
				//global amplitude of the bell
				gain = hslider("v:jupiterbank/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;
};
//
//--------------------------------------------------------------------------------------//
//pulsedEnv2Synth_ui
//--------------------------------------------------------------------------------------//
//
abc_pulsedEnv2Synth_ui(n) = pulsedEnv2Synth(n, envFreq, ratio, spread, carrierFreq, fc, gain)
		with {
				envFreq = hslider("v:pulsedEnv2Synth/envFreq [unit:Hz]", 8.36, 0.001, 500, 0.001);
				ratio = hslider("v:pulsedEnv2Synth/ratio", 140, 0, 500, 0.001);
				spread = hslider("v:pulsedEnv2Synth/spread", 0, 0, 1, 0.001);
				carrierFreq = hslider("v:pulsedEnv2Synth/carrierFreq [unit:Hz]", 880, 0.001, 5000, 0.001);
				fc = hslider("v:pulsedEnv2Synth/fc [unit:Hz]", 1500, 20, 10000, 1);
				gain = hslider("v:pulsedEnv2Synth/gain [unit:dB]", 0, -127, 18, 0.01) : db2gain;	
};

//
//
//--------------------------------------------------------------------------------------//
// PHASE-ALIGNED FORMANT SYNTHESIS
// inspired by Miller Puckette's contribution
// and Philippe Manoury's use in En Echo for soprano and live electronics
//--------------------------------------------------------------------------------------//
//
abc_puckettesPaf_ui = puckettesPaf(f0, cf, bw, gain, sigma, a, wf)
		with {
				f0 = hslider("f0 [unit:Hz]",220, 20, 20000, 0.001);
				cf = hslider("cf [unit:Hz]",500, 20, 20000, 0.001);
				bw = hslider("bw [unit:Hz]", 50, 0.001, 5000, 0.001);
				gain = hslider("gain [unit:dB]", 0, -127., 18., 0.01) : db2gain;
				wf = nentry("wf", 0, 0, 1, 1) : si.smoo; //0 for Gauss function, 1 for Cauchy function
				//
				//sigma for the gaussian function
				sigma = hslider("sigma", 1, 0.001, 5, 0.001);
				//
				//a coefficient for the cauchy function
				a = hslider("a", 1, 0.001, 100, 0.001);	
};

abc_puckettesPaf2_ui = puckettesPaf2(f0, cf, bw, gain, iamp, ifreq, sigma, a, wf)
	with {
			f0 = hslider("f0 [unit:Hz]", 220, 20, 20000, 0.001);
			cf = hslider("cf [unit:Hz]", 500, 20, 20000, 0.001);
			bw = hslider("bw [unit:Hz]", 50, 0.001, 5000, 0.001);
			gain = hslider("gain [unit:dB]", 0, -127., 18., 0.01) : db2gain;
			//
			ifreq = hslider("ifreq [unit:Hz]", 0.1, 0, 1000, 0.001);
			iamp = hslider("iamp", 0, 0, 1, 0.001) : si.smoo;
			//
			//sigma for the gaussian function
			sigma = hslider("sigma", 1, 0.001, 5, 0.001);
			//
			//a coefficient for the cauchy function
			a = hslider("a", 1, 0.001, 100, 0.001);
			//
			wf = nentry("wf", 0, 0, 1, 1) : si.smoo; //0 for Gauss function, 1 for Cauchy function
};

//
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//					UTILITY FUNCTIONS USED IN SEVERAL OTHER FUNCTIONS
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//

//
//--------------------------------------------------------------------------------------//
//STATIC OR ROTATION PHASE BETWEEN 0 AND 1 + CORRESPONDING ANGLE IN RADIANS
//--------------------------------------------------------------------------------------//
//
//A phase generator between 0 and 1, with frequency of rotation and static position
//--------------------------------------------------------------------------------------//
abc_rotationorstaticphase(f, p, dt) = (1-vn) * x + vn * p
with {
		//f is the frequency of rotation
		//p the position if f values zero
		//dt is the interpolation time between the two situations (static / rotation)
		vn = (f == 0) : si.smooth(ba.tau2pole(dt));
		//to manage the case where frequency is zero, smoothly switches from one mode to another//
		x = (os.phasor(1, f), p, 1) : (+, _) : fmod;
};
//
//The corresponding generator as an angle in radians
//--------------------------------------------------------------------------------------//
abc_rotationorstaticangle(f, p, dt) = abc_rotationorstaticphase(f, p, dt) * 2 * ma.PI;
//
abc_linedrive_ui = (_, 30, 127, outputmax, expcurve, 30) : puredataLineDrive
		with {
			outputmax = hslider("v:linedrive/outputmax", 1, 0, 100000, 0.01);
			expcurve = hslider("v:linedrive/expcurve", 1.06, 0.00001, 2., 0.00001);
		};
//
//--------------------------------------------------------------------------------------//
//MULTIPLICATION BY 2*PI
//--------------------------------------------------------------------------------------//
abc_mult2pi = *(2. * ma.PI);
//
//--------------------------------------------------------------------------------------//
//ENVELOPE FOLLOWER
//--------------------------------------------------------------------------------------//
//
abc_envFollower_ui = an.amp_follower_ar(attack, release)
		with {
			attack = hslider("v:envFollower/attack [unit:sec]", 0.001, 0.0001, 1, 0.0001); //attack duration in seconds
			release = hslider("v:envFollower/release [unit:sec]", 0.01, 0.0001, 1, 0.0001); //release duration in seconds
		};
//
//--------------------------------------------------------------------------------------//
//2PI phasor (variation between 0 and 2*PI)
//--------------------------------------------------------------------------------------//
abc_phasor2pi(f) = os.phasor((2. * ma.PI), f);
//
abc_phasor2pi_ui = abc_phasor2pi(freq)
		with {
			freq = hslider("v:phasor2pi/freq [unit:s-1]", 0.1, 0, 20000, 0.00001);
		};
//
//
//--------------------------------------------------------------------------------------//
//POLAR TO CARTESIAN CONVERSION
//angles in radians
//--------------------------------------------------------------------------------------//
//
abc_polar2cartesian = (_, _) <: (_, cos, _, sin) : (*, *);
//
//--------------------------------------------------------------------------------------//
//CARTESIAN TO POLAR CONVERSION
//angles in radians
//--------------------------------------------------------------------------------------//
//
abc_cartesian2polar = permutation <: (module, phase) with {
	permutation(a, b) = (b, a);
	square = _ <: *;
	module = (square, square) : + : sqrt;
	phase = atan2;
};
//

//
//
//
//
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//								CONSTANTS OF THE ABCLIB LIBRARY
//
//--------------------------------------------------------------------------------------//
//--------------------------------------------------------------------------------------//
//
//
//--------------------------------------------------------------------------------------//
//Maximum number of samples for a common delay line
//corresponding to a bit more than 21,8 seconds at 48 KHz
Ndelsamp = 1048576;
//
//For flangers variable delays
Nflangersamp = 262144;


