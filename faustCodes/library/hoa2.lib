//################################### hoa.lib ############################################
// Faust library for high order ambisonic. Its official prefix is `ho`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/hoa.lib>
//########################################################################################

/************************************************************************
 ************************************************************************
FAUST library file
Copyright (C) 2003-2012 GRAME, Centre National de Creation Musicale
----------------------------------------------------------------------
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.

 ************************************************************************
 ************************************************************************/

ma = library("maths.lib");
si = library("signals.lib");
ba = library("basics.lib");
os = library("oscillators.lib");
ho = library("hoa.lib");
ro = library("routes.lib");
de = library("delays.lib");

declare name "High Order Ambisonics library";
declare version "0.4";
declare author "Pierre Guillot";
declare author "Eliott Paris";
declare author "Julien Colafrancesco";
declare author "Wargreen";
declare author "Alain Bonardi";
declare author "Paul Goutmann";
declare copyright "2012-2013 Guillot, Paris, Colafrancesco, CICM labex art H2H, U. Paris 8, 2019 Wargreen, 2022-2025 Bonardi, Goutmann";


//========================================================================================
//==================================2D Functions==========================================
//========================================================================================
//========================================================================================

//=========================2D Encoding/decoding Functions=================================
//========================================================================================

//----------------------`(ho.)encoder`---------------------------------
// Ambisonic encoder. Encodes a signal in the circular harmonics domain
// depending on an order of decomposition and an angle.
//
// #### Usage
//
// ```
// encoder(N, x, a) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `x`: the signal
// * `a`: the angle
//----------------------------------------------------------------
encoder(0, x, a) = x;
encoder(N, x, a) = encoder(N-1, x, a), x*sin(N*a), x*cos(N*a);


//-------`(ho.)rEncoder`----------
// Ambisonic encoder in 2D including source rotation. A mono signal is encoded at a certain ambisonic order
// with two possible modes: either rotation with an angular speed, or static with a fixed angle (when speed is zero).
//
// #### Usage
//
// ```
// _ : rEncoder(N, sp, a, it) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `sp`: the azimuth speed expressed as angular speed (2PI/sec), positive or negative
// * `a`: the fixed azimuth when the rotation stops (sp = 0) in radians
// * `it` : interpolation time (in milliseconds) between the rotation and the fixed modes
//-----------------------------
rEncoder(N, sp, a, it) = thisEncoder
with {
    basicEncoder(sig, angle) = ho.encoder(N, sig, angle);
    thisEncoder = (_, rotationOrStaticAngle) : basicEncoder
    with {
        //converting the static angle from radians to [0; 1]
        an = (a / (2 * ma.PI), 1) : fmod;
        rotationOrStaticAngle = ((1-vn) * x + vn * an) * 2 * ma.PI;
        //to manage the case where frequency is zero, smoothly switches from one mode to another//
        vn = (sp == 0) : si.smooth(ba.tau2pole(it));
        x = (os.phasor(1, sp), an, 1) : (+, _) : fmod;
    };
};


//-------`(ho.)aleaEncoder`----------
// Ambisonic aleatory encoder in 2D. A mono signal is encoded at an ambisonic order
// with a random position of the source around an angle inside an angular range.
//
// #### Usage
//
// ```
// _ : aleaEncoder(N, freq, angle, deltaAngle, index) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `freq`: the frequency in Herz of update of the random position of the source
// * `angle`: the angle in degrees on which the source is centered
// * `deltaAngle` : the range of angular variation of the source in degrees
// * `index` : the index of the random decoder, used when there are several random decoders, but can be left to 0 when there is only one.
//-----------------------------
aleaEncoder(N, freq, angle, deltaAngle, index) = thisAleaEncoder
		with {
			ramp = os.phasor(1, freq);
			th = (ramp > 0.001) * (ramp@1 <= 0.001);
			temporalFilter = ba.sAndH(th);
			//computes the temporal interval taking into account the case when f=0 and when f<0
			dt = (ma.SR, max(0.00001, freq)) : / : ma.fabs ;
			randomValue = + (90000 + index * 20) ~ *(1410065407);
			noiseValue = randomValue / 2147483647.0;
			randomAngle = noiseValue : *(deltaAngle / 2) : +(angle) : temporalFilter : ba.line(dt) : *(ma.PI) : /(180);
			basicEncoder(sig, angle) = ho.encoder(N, sig, angle);
    		thisAleaEncoder = (_, randomAngle) : basicEncoder;
};


//-------`(ho.)stereoEncoder`----------
// Encoding of a stereo pair of channels with symetric angles (a/2, -a/2).
//
// #### Usage
//
// ```
// _,_ : stereoEncoder(N, a) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `a` : opening angle in radians, left channel at a/2 angle, right channel at -a/2 angle
//-----------------------------
stereoEncoder(N, a) = (leftEncoder, rightEncoder) :> si.bus(2*N+1)
with {
    basicEncoder(sig, angle) = ho.encoder(N, sig, angle);
    leftEncoder = (_, a / 2) : basicEncoder;
    rightEncoder = (_, -a /2) : basicEncoder;
};


//-------`(ho.)multiEncoder`----------
// Encoding of a set of P signals distributed on the unit circle according to a list of P speeds and P angles.
//
// #### Usage
//
// ```
// _,_, ... : multiEncoder(N, lspeed, langle, it) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `lSpeed` : a list of speeds in turns by second (one speed per input signal, positive or negative)
// * `lAngle` : a list of angles in radians on the unit circle to localize the sources (one angle per input signal)
// * `it` : interpolation time (in milliseconds) between the rotation and the fixed modes.
//-----------------------------
multiEncoder(N, lSpeed, lAngle, it) = par(i, P, ho.rEncoder(N, ba.take(i+1, lSpeed), ba.take(i+1, lAngle), it)) :> si.bus(2*N+1)
with {
    P = outputs(lSpeed); //supposed to be the same as the number of angles in lAngle
};


//-------`(ho.)multiAleaEncoder`----------
// Aleatory encoding of a set of P signals.
// The signals are distributed on the unit circle.
// Each of them is centered around an angle, within an angular range and updated at a certain frequency.
//
// #### Usage
//
// ```
// _,_, ... : multiAleaEncoder(N, lFreq, lAngle, lDeltaAngle) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `lFreq` : a list of frequencies in Herz of update of the random position of each source
// * `lAngle` : a list of angles in degrees on which each source is centered
// * `lDeltaAngle` : a list of ranges of angular variation of each source in degrees
//-----------------------------
multiAleaEncoder(N, lFreq, lAngle, lDeltaAngle) = par(i, P, aleaEncoder(N, ba.take(i+1, lFreq), ba.take(i+1, lAngle), ba.take(i+1, lDeltaAngle), i)) :> si.bus(2*N+1)
with {
	P = outputs(lFreq); 
};


//--------------------------`(ho.)decoder`--------------------------------
// Decodes an ambisonics sound field for a circular array of loudspeakers.
//
// #### Usage
//
// ```
// _ : decoder(N, P) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `P`: the number of speakers (constant numerical expression)
//
// #### Note
//
// The number of loudspeakers must be greater or equal to 2n+1.
// It's preferable to use 2n+2 loudspeakers.
//-------------------------------------------------------------------
decoder(N, P) = par(i, 2*N+1, _) <: par(i, P, speaker(N, 2 * ma.PI*i/P))
with {
    speaker(N,a) = /(2), par(i, 2*N, _), ho.encoder(N, 2/P, a) : si.dot(2*N+1);
};


//-----------------------`(ho.)decoderStereo`------------------------
// Decodes an ambisonic sound field for stereophonic configuration.
// An "home made" ambisonic decoder for stereophonic restitution
// (30° - 330°): Sound field lose energy around 180°. You should
// use `inPhase` optimization with ponctual sources.
// #### Usage
//
// ```
// _ : decoderStereo(N) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
//--------------------------------------------------------------
decoderStereo(N) = decoder(N, P) <: (par(i, 2*N+2, gainLeft(360 * i / P)) :> _),
    (par(i, 2*N+2, gainRight(360 * i / P)) :> _)
with {
    P = 2*N+2;

    gainLeft(a) = _ * sin(ratio_minus + ratio_cortex)
    with {
        ratio_minus = ma.PI*.5 * abs((30 + a) / 60 * ((a <= 30)) + (a - 330) / 60 * (a >= 330));
        ratio_cortex= ma.PI*.5 * abs((120 + a) / 150 * (a > 30) * (a <= 180));
    };

    gainRight(a) = _ * sin(ratio_minus + ratio_cortex)
    with {
        ratio_minus = ma.PI*.5 * abs((390 - a) / 60 * (a >= 330) + (30 - a) / 60 * (a <= 30));
        ratio_cortex= ma.PI*.5 * abs((180 - a) / 150 * (a < 330) * (a >= 180));
    };
};


//-------`(ho.)iBasicDecoder`----------
// The irregular basic decoder is a simple decoder that projects the incoming ambisonic situation
// to the loudspeaker situation (P loudspeakers) whatever it is, without compensation.
// When there is a strong irregularity, there can be some discontinuity in the sound field.
//
// #### Usage
//
// ```
// _,_, ... : iBasicDecoder(N,la, direct, shift) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (there are 2*N+1 inputs to this function)
// * `la` : the list of angles in degrees, for instance (0, 85, 182, 263) for four loudspeakers
// * `direct`: 1 for direct mode, -1 for the indirect mode (changes the rotation direction)
// * `shift` : angular shift in degrees to easily adjust angles
//-----------------------------
iBasicDecoder(N, la, direct, shift) = (par(i, 2*N+1, _) <: par(i, P, speaker(N, ang(i))))
with {
    P = outputs(la);
    ang(i) = (ba.take(i+1, la)  - direct * shift) * direct * ma.PI / 180.;
    speaker(N,alpha) = /(2), par(i, 2*N, _), ho.encoder(N,2/P,alpha) : si.dot(2*N+1);
};


//-------`(ho.)circularScaledVBAP`----------
// The function provides a circular scaled VBAP with all loudspeakers and the virtual source on the unit-circle.
//
// #### Usage
//
// ```
// _ : circularScaledVBAP(l, t) : _,_, ...
// ```
//
// Where:
//
// * `l` : the list of angles of the loudspeakers in degrees, for instance (0, 85, 182, 263) for four loudspeakers
// * `t` : the current angle of the virtual source in degrees
//-----------------------------
circularScaledVBAP(l, t) = thisCircularVbap
with {
        //modulo indexes between 1 and the number of elements of the list
    	modIndex(i, l) = ma.modulo(i, outputs(l)) + 1;
    	//picks up the ith angle
    	getAngle(i, l) = ba.take(modIndex(i, l), l); 
		//computes the cross product between two points on the unit circle set by their polar angles u and v
        diffSin(u, v) = sin(ma.deg2rad(v-u));
		//computation of the scaled VBAP gain of a pair
		normalizedVBAPGain(t1, t2, t) = ((diffSin(t2, t) <:(_, _, _)), (ma.signum(diffSin(t2, t1)) <: (_, _)), (diffSin(t, t1) <:(_, _, _))) : (*, *, *, *) : p1 : (_, _, (+ : sqrt : avoidZero <: (_, _))) : p2 : (/, /)
		with {
				//function to avoid division by zero (for the normalization of the vector of gains)
                avoidZero = _ <:(_, (_ == 0)) : +;
				//permutations to be used to compute normalizedVBAPGain
				p1(a, b, c, d) = (b, c, d, a);
				p2(a, b, c, d) = (a, c, b, d);
				//
		};
        //tests if the virtual source (at t angle) is between the ith and the (i+1)th loudspeakers of the l list
        //the ith source is named as A, the (i+1)th source is named as B, the virtual source is named as C
        isBetween(i, l, t) = betweenTest
        with {
            //computes the cross product between the ith and (i+1)th loudspeakers (respectively points A and B)
            ab_cp = diffSin(getAngle(i, l), getAngle(i+1, l));
            //computes the cross product between the ith loudspeaker and the virtual source (respectively points A and C)
            ac_cp = diffSin(getAngle(i, l), t);
            //computes the cross product between the virtual source and the (i+1)th loudspeaker (respectively points C and B)
            cb_cp = diffSin(t, getAngle(i+1, l));
            //the test returns true if all cross products have the same sign
            betweenTest = ((ab_cp > 0)*(ac_cp >= 0)*(cb_cp > 0) + (ab_cp < 0)*(ac_cp <= 0)*(cb_cp < 0)) > 0;
        };
		//number of loudspeakers
		p = outputs(l);
		//
        //tests all successive pairs of loudspeakers to check is the virtual source is inside this pair
	    pairCondition = par(i, p, isBetween(i, l, t));
	    //angle of the closest lower loudspeaker
	    angle1 = sum(i, p, getAngle(i, l) * ba.take(i+1, pairCondition));
        //angle of the closest superior loudspeaker
	    angle2 = sum(i, p, getAngle(i+1, l) * ba.take(i+1, pairCondition));
		//index of the loudspeaker corresponding to the closest lower angle
		thisPairInd1 = pairCondition : sum(i, p, *(i));
		//index of the loudspeaker corresponding to the closest superior angle
		thisPairInd2 = ma.modulo(thisPairInd1 + 1, p);
		//amplitudes of the p loudspeakers: the value is computed thanks to scaledVBAPGain function for the two loudspeakers of the active pair, and set to 0 for the other ones
		amps = (angle1, angle2, t) : normalizedVBAPGain : ((_ <: par(i, p, *(i == thisPairInd1))), (_ <: par(i, p, *(i == thisPairInd2)))) : ro.interleave(p, 2) : par(i, p, +);
		//the set of p amplitudes is applied to the virtual source input
		thisCircularVbap = (amps, (_<:si.bus(p))) : ro.interleave(p, 2) : par(i, p, *);
};


//-------`(ho.)imlsDecoder`----------
// Irregular decoder in 2D for an irregular configuration of P loudspeakers
// using 2D VBAP for compensation.
//
// #### Usage
//
// ```
// _,_, ... : imlsDecoder(N,la, direct, shift) : _,_, ...
// ``` 
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `la` : the list of P angles in degrees, for instance (0, 85, 182, 263) for four loudspeakers
// * `direct`: 1 for direct mode, -1 for the indirect mode (changes the rotation direction)
// * `shift` : angular shift in degrees to easily adjust angles
//-----------------------------
imlsDecoder(N, la, direct, shift) = si.bus(2*N+1) : iVBAPDecoder
with {
    P = outputs(la);
    //The VBAP decoder uses VBAP compensation: it balances the regular decoder output enabling to use irregular angular setup.
    Q = max(2*N+2, P);
    iVBAPDecoder = ho.decoder(N, Q) : par(i, Q, circularScaledVBAP(la, (i * 360 / Q - direct * shift) * direct)) :> si.bus(P);
};


//-------`(ho.)iDecoder`----------
// General decoder in 2D enabling an irregular multi-loudspeaker configuration
// and to switch between multi-channel and stereo.
//
// #### Usage
//
// ```
// _,_, ... : iDecoder(N, la, direct, st, g) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `la`: the list of angles in degrees
// * `direct`: 1 for direct mode, -1 for the indirect mode (changes the rotation direction)
// * `shift` : angular shift in degrees to easily adjust angles
// * `st`: 1 for stereo, 0 for multi-loudspeaker configuration. When 1, stereo sounds goes through the first two channels
// * `g` : gain between 0 and 1
//-----------------------------
iDecoder(N, la, direct, shift, st, g) = thisDecoder
with {
    //p is the number of outputs
    P = outputs(la);
    ambi = 1 - st;
    //
    //for stereo decoding
    paddedStereoDecoder(N, P) = (gDecoderStereo, (0 <: si.bus(P-2)))
    with {
        leftDispatcher = _<:(*(1-direct), *(direct));
        rightDispatcher = _<:(*(direct), *(1-direct));
        gDecoderStereo = ho.decoderStereo(N) : (*(g), *(g)) : (leftDispatcher, rightDispatcher) :> (_,_);
    };
    //
    thisDecoder = si.bus(2*N+1) <: (si.bus(2*N+1), si.bus(2*N+1)) : (imlsDecoder(N, la, direct, shift), paddedStereoDecoder(N, P)) : (par(i, P, *(ambi)), *(st), *(st), si.bus(P-2))  :> si.bus(P) : par(i, P, *(g));
};


//============================Analysis Functions======================================
//In order to apprehend or anticipate the localization accuracy of an ambisonic reproduction, 
//two indices have been theorized by Gerzon based on Makita's theory of perception: 
//the energy vector and the velocity vector. 
//========================================================================================


//-------`(ho.)vectorVE`----------
// The velocity vector is valid for frequencies below 700 Hz, its direction corresponds 
//to the apparent direction of the source and its norm corresponds to the precision (or blur) 
//of the rendering. The energy vector is the analog of the velocity vector for frequencies 
//from 500 Hz to 5 kHz. These localization indices, calculated on the signals sent to the loudspeakers, 
//enable ambisonic signals to be optimized for the best possible rendering in a given situation. 
//The function receives post-decodage signals and gives the coordinate of the two vectors.
//
// #### Usage
//
// ```
// _,_, ... : vectorVE(la) : _,_,_,_,
// ```
//
// Where:
//
// * `laz`: the list of azimuth in degrees
//-----------------------------

vectorVE(laz) = thisVectorVE
with{
    p = outputs(laz);
    ang(i) = ba.take(i+1, laz);
    //Polar to cartesian coordinates
    lx(p) = par(i, p, * (cos((ang(i) + 90) / 180 * ma.PI)));
    ly(p) = par(i, p, * (sin((ang(i) + 90) / 180 * ma.PI)));
    
    clip(mini,maxi) = min(maxi, max(mini, _));
    parSquare(p) = par(i, p, ^(2));
    sumOfSquare(p) = par(i, p, _ <: (*)) :> _ ;
    simpleSum(p) = si.bus(p) :> _ ;
    zeroException =  _ <: (_ == (0)) * ma.MIN, _  : + ;

    vx(p) = si.bus(2*p+2) : par(i, 2, (lx(p):simpleSum(p))), si.bus(2):route(4,4, 1, 1, 2, 3, 3, 4, 4, 2) : /, / : clip(-1, 1), clip(-1,1);
    vy(p) = si.bus(2*p+2) : par(i, 2, (ly(p):simpleSum(p))), si.bus(2):route(4,4, 1, 1, 2, 3, 3, 4, 4, 2) : /, / : clip(-1, 1), clip(-1,1);

thisVectorVE = si.bus(p) <: si.bus(p), (parSquare(p)<:si.bus(p), (simpleSum(p):zeroException)), (simpleSum(p):zeroException) <: vx(p), vy(p) : ro.interleave(2, 2);
};


//=========================2D Optimization Functions======================================
// Functions to weight the circular harmonics signals depending on the ambisonic optimization.
// It can be `basic`for no optimization, `maxRe` or `inPhase`.
//========================================================================================

//----------------`(ho.)optimBasic`-------------------------
// The basic optimization has no effect and should be used for a perfect
// circle of loudspeakers with one listener at the perfect center loudspeakers
// array.
//
// #### Usage
//
// ```
// _ : optimBasic(N) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
//-----------------------------------------------------
optimBasic(N) = par(i, 2*N+1, _);


//----------------`(ho.)optimMaxRe`-------------------------
// The maxRe optimization optimizes energy vector. It should be used for an
// auditory confined in the center of the loudspeakers array.
//
// #### Usage
//
// ```
// _ : optimMaxRe(N) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
//-----------------------------------------------------
optimMaxRe(N) = par(i, 2*N+1, optim(i, N, _))
with {
    optim(i, N, _)= _ * cos(indexabs / (2*N+1) * ma.PI)
    with {
        numberOfharmonics = 2 * N + 1;
        indexabs = (int)((i - 1) / 2 + 1);
    };
};


//----------------`(ho.)optimInPhase`-------------------------
//  The inPhase optimization optimizes energy vector and put all loudspeakers signals
// in phase. It should be used for an auditory.
//
// #### Usage
//
// ```
// _ : optimInPhase(N) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
//-----------------------------------------------------
optimInPhase(N) = par(i, 2*N+1, optim(i, N, _))
with {
    optim(i, N, _)= _ * (fact(N)^2.) / (fact(N+indexabs) * fact(N-indexabs))
    with {
        indexabs = (int)((i - 1) / 2 + 1);
        fact(0) = 1;
        fact(n) = n * fact(n-1);
    };
};


//-------`(ho.)optim`----------
// Ambisonic optimizer including the three elementary optimizers:
// `(ho).optimBasic`, `(ho).optimMaxRe` and `(ho.)optimInPhase`.
//
// #### Usage
//
// ```
// _,_, ... : optim(N, ot) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `ot` : optimization type (0 for `optimBasic`, 1 for `optimMaxRe`, 2 for `optimInPhase`)
//-----------------------------
optim(N, ot) = thisOptimizer
with {
    optb = (ot == 0) : si.smoo;
    optm = (ot == 1) : si.smoo;
    opti = (ot == 2) : si.smoo;
    thisOptimizer = ((si.bus(2*N+1) <: ((si.bus(2*N+1):ho.optimBasic(N)), (si.bus(2*N+1):ho.optimMaxRe(N)), (si.bus(2*N+1):ho.optimInPhase(N)))), ((optb <: si.bus(2*N+1)), (optm <: si.bus(2*N+1)), (opti <: si.bus(2*N+1)))) : ro.interleave(6*N+3, 2) : par(i, 6*N+3, *) :> si.bus(2*N+1);
};


//----------------`(ho.)wider`-------------------------
// Can be used to widen the diffusion of a localized sound. The order
// depending signals are weighted and appear in a logarithmic way to
// have linear changes.
//
// #### Usage
//
// ```
// _ : wider(N,w) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `w`: the width value between 0 - 1
//-----------------------------------------------------
wider(N, w) = par(i, 2*N+1, perform(N, w, i, _))
with {
    perform(N, w, i, _) = _ * (log(N+1) * (1 - w) + 1) * clipweight
    with {
        clipweight = weighter(N, w, i) * (weighter(N, w, i) > 0) * (weighter(N, w, i) <= 1) + (weighter(N, w, i) > 1)
        with {
            weighter(N, w, 0) = 1.;
            weighter(N, w, i) = (((w * log(N+1)) - log(indexabs)) / (log(indexabs+1) - log(indexabs)))
            with {
                indexabs = (int)((i - 1) / 2 + 1);
            };
        };
    };
};


//-------`(ho.)mirror`----------
// Mirroring effect on the sound field.
//
// #### Usage
//
// ```
// _,_, ... : mirror(N, fa) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `fa` : mirroring type (1 = original sound field, 0 = original+mirrored sound field, -1 = mirrored sound field)
//-----------------------------
mirror(N, fa) = (*(1), par(i, N, (*(fa), *(1))));


//----------------`(ho.)map`-------------------------
// It simulates the distance of the source by applying a gain
// on the signal and a wider processing on the soundfield.
//
// #### Usage
//
// ```
// map(N, x, r, a)
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `x`: the signal
// * `r`: the radius
// * `a`: the angle in radian
//-----------------------------------------------------
map(N, x, r, a) = encoder(N, x * volume(r), a) : wider(N, ouverture(r))
with {
    volume(r) = 1. / (r * r * (r > 1) + (r <= 1));
    ouverture(r) = r * (r < 1) + (r >= 1);
};


//----------------`(ho.)rotate`-------------------------
// Rotates the sound field.
//
// #### Usage
//
// ```
// _ : rotate(N, a) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `a`: the angle in radian
//-----------------------------------------------------
rotate(N, a) = par(i, 2*N+1, _) <: par(i, 2*N+1, rotation(i, a))
with {
    rotation(i, a) = (par(j, 2*N+1, gain1(i, j, a)), par(j, 2*N+1, gain2(i, j, a)), par(j, 2*N+1, gain3(i, j, a)) :> _)
    with {
        indexabs = (int)((i - 1) / 2 + 1);
        gain1(i, j, a) = _ * cos(a * indexabs) * (j == i);
        gain2(i, j, a) = _ * sin(a * indexabs) * (j-1 == i) * (j != 0) * (i%2 == 1);
        gain3(i, j, a) = (_ * sin(a * indexabs)) * (j+1 == i) * (j != 0) * (i%2 == 0) * (-1);
    };
};


//-------`(ho.)scope`----------
// Produces an XY pair of signals representing the ambisonic sound field.
//
// #### Usage
//
// ```
// _,_, ... : scope(N, rt) : _,_
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `rt` : refreshment time in milliseconds
//-----------------------------
scope(N, rt) = thisScope
with {
    //Angle sweeping at a speed corresponding to refresh period between 0 and 2*PI
    theta = os.phasor(1, 1/rt) * 2 * ma.PI;
    //we get the vector of harmonic functions thanks to the encoding function//
    harmonicsVector = ho.encoder(N, 1, theta);
    //
    normalizedVector(N) = si.bus(N) <: (si.bus(N), norm) : ro.interleave(N, 2) : par(i, N, /)
    with {
        norm = par(i, N, _ <:(_,_) : *) :> _ : sqrt <: ((_ == 0), (_ > 0), _) : (_,*) : + <: si.bus(N);
    };
    //building (2N+1) normalized vectors
    inputVector = (*(0.5), par(i, (2*N), _)) : normalizedVector(2*N+1);
    normalizedHarmonics = harmonicsVector : normalizedVector(2*N+1);
    //
    rho = (inputVector, normalizedHarmonics) : si.dot(2*N+1) ;
    thisScope = (rho <: (ma.fabs, (_ >= 0))) : ((_ <: (_,_)), _) : (*(sin(theta)), *(cos(theta)), _) : (*(-1), _,_);
};


//============================Spatial Sound Processes ====================================
// We propose implementations of processes intricated to the ambisonic model.
// The process is implemented using as many instances as the number of harmonics at at certain order.
// The key control parameters of these instances are computed thanks to distribution functions
// (th functions below) and to a global driving factor.
//========================================================================================

//-------`(ho.)fxDecorrelation`----------
// Spatial ambisonic decorrelation in fx mode.
//
// `fxDecorrelation` applies decorrelations to spatial components already created.
// The decorrelation is defined for each #i spatial component among P=2\*N+1 at the ambisonic order `N`
// as a delay of 0 if factor `fa` is under a certain value 1-(i+1)/P and d\*F((i+1)/p) in the contrary case,
// where `d` is the maximum delay applied (in samples) and F is a distribution function for durations.
// The user can choose this delay time distribution among 22 different ones.
// The delay increases according to the index of ambisonic components.
// But it increases at each step and it is modulated by a threshold.
// Therefore, delays are progressively revealed when the factor increases:
//
// * when the factor is close to 0, only upper components are delayed;
// * when the factor increases, more and more components are delayed.
//
//H                 THRESHOLD            DELAY
//0                 1-1/P                0 OR DELAY*F(1/P)
//-1                1-2/P                0 OR DELAY*F(2/P)
//1                 1-3/P                0 OR DELAY*F(3/P)
//-2                1-4/P                0 OR DELAY*F(4/P)
//2                 1-5/P                0 OR DELAY*F(5/P)
//...
//-(N-1)            1-(P-3)/P            0 OR DELAY*F((P-3)/P)
//(N-1)             1-(P-2)/P            0 OR DELAY*F((P-2)/P)
//-N                1-(P-1)/P            0 OR DELAY*F((P-1)/P)
//N                 1-P/P                0 OR DELAY*F(P/P)
//
//
// #### Usage
//
// ```
// _,_, ... : fxDecorrelation(N, d, wf, fa, fd, tf) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `d`: the maximum delay applied (in samples)
// * `wf`: window frequency (in Hz) for the overlapped delay
// * `fa`: decorrelation factor (between 0 and 1)
// * `fd`: feedback / level of reinjection (between 0 and 1)
// * `tf`: type of function of delay distribution (integer, between 0 and 21)
//-----------------------------
fxDecorrelation(N, d, wf, fa, fd, tf) = fxDelay(N, ld, wf, lf)
with {
    //number of components
    P = 2*N+1 ; 
    //list of delay time - I THINK THAT WE CAN DELETE P HERE
    ld = par(i, P, dur(d, i, P, fa, tf));
    //list of feedback level
    lf = par(i, P, (fd*fa*env(fa,i,P)));
    //
    //actives the feedback amount when the factor is upper the threshold of the spatial component
    env(fa, i, P) = (fa > ((P-i-1)/P)) : si.smooth(ba.tau2pole(0.005));
    //
    //computes the ith duration of the ith delay in samples with twenty two possibilities of distribution
    elemdur(d, i, p, fa, tf, ind) = (tf == ind) * (fa > (1 - x)) * d * x * fa
    with {
        x = th(ind, i, p);
    };
    //duration in samples computed as a sum of the 22 cases//
    dur(d, i, p, fa, tf) = sum(ind, 22, elemdur(d, i, p, fa, tf, ind)) : int;
};

//-------`(ho.)synDecorrelation`----------
// Spatial ambisonic decorrelation in syn mode.
//
// `synDecorrelation` generates spatial decorrelated components in ambisonics from one mono signal.
// The decorrelation is defined for each #i spatial component among P=2\*N+1 at the ambisonic order `N`
// as a delay of 0 if factor `fa` is under a certain value 1-(i+1)/P and d\*F((i+1)/p) in the contrary case,
// where `d` is the maximum delay applied (in samples) and F is a distribution function for durations.
// The user can choose this delay time distribution among 22 different ones.
// The delay increases according to the index of ambisonic components.
// But it increases at each step and it is modulated by a threshold.
// Therefore, delays are progressively revealed when the factor increases:
//
// * when the factor is close to 0, only upper components are delayed;
// * when the factor increases, more and more components are delayed.
//
// When the factor is between [0; 1/P], upper harmonics are progressively faded and the level of the H0 component is compensated
// to avoid source localization and to produce a large mono.
//
//H                THRESHOLD            DELAY
//0                1-1/P                0 OR DELAY*F(1/P)
//-1               1-2/P                0 OR DELAY*F(2/P)
//1                1-3/P                0 OR DELAY*F(3/P)
//-2               1-4/P                0 OR DELAY*F(4/P)
//2                1-5/P                0 OR DELAY*F(5/P)
//...
//-(N-1)           1-(P-3)/P            0 OR DELAY*F((P-3)/P)
//(N-1)            1-(P-2)/P            0 OR DELAY*F((P-2)/P)
//-N               1-(P-1)/P            0 OR DELAY*F((P-1)/P)
//N                1-P/P                0 OR DELAY*F(P/P)
//
//
// #### Usage
//
// ```
// _ : synDecorrelation(N, d, wf, fa, fd, tf) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `d`: the maximum delay applied (in samples)
// * `wf`: window frequency (in Hz) for the overlapped delay
// * `fa`: decorrelation factor (between 0 and 1)
// * `fd`: feedback / level of reinjection (between 0 and 1)
// * `tf`: type of function of delay distribution (integer, between 0 and 21)
//-----------------------------
synDecorrelation(N, d, wf, fa, fd, tf) = thisSynDecorrelation 
with {
    P = 2*N+1 ; 
    //list of delay time - I THINK THAT WE CAN DELETE P HERE
    ld = par(i, P, dur(d, i, P, fa, tf));
    //list of feedback level 
    lf = par(i, P, (fd * fa * env(fa,i,P)));
    //list of gain
    lg = par(i, P, gain(fa, i, P));
    //
    //actives the feedback amount when the factor is upper the threshold of the spatial component
    env(fa, i, P) = (fa > ((P-i-1)/P)) : si.smooth(ba.tau2pole(0.005));
    //computes the ith gain to avoid directional sources when 0<fa<1/P
    gain(fa, i, P) = ((i > 0) * P * min(fa, 1/P)) + ((i == 0) * (sqrt(P) * (1 - (P - sqrt(P)) * min(fa, 1/P)))) : si.smooth(ba.tau2pole(0.005));
    //computes the ith duration of the ith delay in samples with twenty two possibilities of distribution
    elemdur(d, i, p, fa, tf, ind) = (tf == ind) * (fa > (1 - x)) * d * x * fa
    with {
        x = th(ind, i, p);
    };
    //duration in samples computed as a sum of the 22 cases//
    dur(d, i, p, fa, tf) = sum(ind, 22, elemdur(d, i, p, fa, tf, ind)) : int;
    thisSynDecorrelation = synDelay(N, ld, wf, lf) : fxGain(N, lg) ;
};

//-------`(ho.)fxRingMod`----------
// Spatial ring modulation in fx mode.
//
// `fxRingMod` applies ring modulation to spatial components already created.
// The ring modulation is defined for each spatial component among P=2\*n+1 at the ambisonic order `N`.
// For each spatial component #i, the result is either the original signal or a ring modulated signal
// according to a threshold that is i/P.
//
// The general process is drive by a factor `fa` between 0 and 1 and a modulation frequency `f0`.
// If `fa` is greater than theshold (P-i-1)/P, the ith ring modulator is on with carrier frequency of f0\*(i+1)/P.
// On the contrary, it provides the original signal.
//
// Therefore ring modulators are progressively revealed when `fa` increases.
//
//H                THRESHOLD                OUTPUT
//0                (P-1)/P                  ORIGINAL OR RING MODULATION BY F0*1/P
//-1               (P-2)/P                  ORIGINAL OR RING MODULATION BY F0*2/P
//1                (P-3)/P                  ORIGINAL OR RING MODULATION BY F0*3/P
//-2               (P-4)/P                  ORIGINAL OR RING MODULATION BY F0*4/P
//2                (P-5)/P                  ORIGINAL OR RING MODULATION BY F0*5/P
//...
//-(N-1)           3/P                      ORIGINAL OR RING MODULATION BY F0*(P-3)/P
//(N-1)            2/P                      ORIGINAL OR RING MODULATION BY F0*(P-2)/P
//-N               1/P                      ORIGINAL OR RING MODULATION BY F0*(P-1)/P
//N                0                        ORIGINAL OR RING MODULATION BY F0*P/P=F0
//
//
// #### Usage
//
// ```
// _,_, ... : fxRingMod(N, f0, fa, tf) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `f0`: the maximum delay applied (in samples)
// * `fa`: decorrelation factor (between 0 and 1)
// * `tf`: type of function of delay distribution (integer, between 0 and 21)
//-----------------------------
fxRingMod(N, f0, fa, tf) = par(i, 2*N+1, gate_ringmod(f0, i, 2*N+1, fa, tf))
with {
    //
    env1(fa, i, N) = (fa > ((N-i-1)/N)) : si.smooth(ba.tau2pole(0.005));
    env1c(fa, i, N) = 1 - env1(fa, i, N);
    //
    gate_ringmod(f, i, N, fa, tf) = _ <: _ * os.osccos(freq(f, i, N, tf)) * env1(fa, i, N), _ * env1c(fa, i, N) : +;
    //
    ringmodfreq(f, i, N, tf, ind) = (tf == ind) * f * x * coef
    with {
        x = th(ind, i, N);
        coef = min(1, max(N * (fa - (N - i - 1) / N), 0));
    };
    //
    freq(f, i, N, tf) = sum(ind, 22, ringmodfreq(f, i, N, tf, ind)) : int;
};

//-------`(ho.)synRingMod`----------
// Spatial ring modulation in syn mode.
//
// `synRingMod` generates spatial components in ambisonics from one mono signal thanks to ring modulation.
// The ring modulation is defined for each spatial component among P=2\*n+1 at the ambisonic order `N`.
// For each spatial component #i, the result is either the original signal or a ring modulated signal
// according to a threshold that is i/P.
//
// The general process is drive by a factor `fa` between 0 and 1 and a modulation frequency `f0`.
// If `fa` is greater than theshold (P-i-1)/P, the ith ring modulator is on with carrier frequency of f0\*(i+1)/P.
// On the contrary, it provides the original signal.
//
// Therefore ring modulators are progressively revealed when `fa` increases.
// When the factor is between [0; 1/P], upper harmonics are progressively faded and the level of the H0 component is compensated
// to avoid source localization and to produce a large mono.
//
//H                 THRESHOLD                OUTPUT
//0                 (P-1)/P                  ORIGINAL OR RING MODULATION BY F0*1/P
//-1                (P-2)/P                  ORIGINAL OR RING MODULATION BY F0*2/P
//1                 (P-3)/P                  ORIGINAL OR RING MODULATION BY F0*3/P
//-2                (P-4)/P                  ORIGINAL OR RING MODULATION BY F0*4/P
//2                 (P-5)/P                  ORIGINAL OR RING MODULATION BY F0*5/P
//...
//-(N-1)            3/P                      ORIGINAL OR RING MODULATION BY F0*(P-3)/P
//(N-1)             2/P                      ORIGINAL OR RING MODULATION BY F0*(P-2)/P
//-N                1/P                      ORIGINAL OR RING MODULATION BY F0*(P-1)/P
//N                 0                        ORIGINAL OR RING MODULATION BY F0*P/P=F0
//
//
// #### Usage
//
// ```
// _ : synRingMod(N, f0, fa, tf) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `f0`: the maximum delay applied (in samples)
// * `fa`: decorrelation factor (between 0 and 1)
// * `tf`: type of function of delay distribution (integer, between 0 and 21)
//-----------------------------
synRingMod(N, f0, fa, tf) = _ <: par(i, 2*N+1, crossfade_ringmod(f0, i, 2*N+1, fa, tf))
with {
    //
    env1(fa, i, N) = (fa > ((N-i-1)/N)) : si.smooth(ba.tau2pole(0.005));
    env1c(fa, i, N) = 1 - env1(fa, i, N);
    env2(fa, i, N) = ((i > 0) * N * min(fa, 1/N)) + ((i == 0) * (sqrt(N) * (1 - (N - sqrt(N)) * min(fa, 1/N)))) : si.smooth(ba.tau2pole(0.005));
    //
    crossfade_ringmod(f, i, N, fa, tf) = _ <: _ * os.osccos(freq(f, i, N, tf)) * env1(fa, i, N), _ * env1c(fa, i, N) :> _ * env2(fa, i, N);
    //
    ringmodfreq(f, i, N, tf, ind) = (tf == ind) * f * x * coef
    with {
        x = th(ind, i, N);
        coef = min(1, max(N * (fa - (N - i - 1) / N), 0));
    };
    //
    freq(f, i, N, tf) = sum(ind, 22, ringmodfreq(f, i, N, tf, ind)) : int;
};


//-------`(ho.)fxDelay`----------
// Spatial ambisonic delay in fx mode.
//
// `fxDelay` applies delay lines to spatial components already created.
// The delay time is defined for each spatial component among P=2\*n+1 at the ambisonic order `N`.
//
//
// #### Usage
//
// ```
// _,_, ... : fxDelay(N, ld, wf, lf) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `ld`: list of delay time (in sample)
// * `wf`: window frequency (in Hz) for the overlapped delay
// * `lf`: list of feedback amont
//-----------------------------
fxDelay(N, ld, wf, lf) = par(i, 2*N+1, fdOverlappedDelay(ba.take(i+1, ld), 262144, wf, ba.take(i+1, lf)))
with{
    fdOverlappedDelay(nsamp, nmax, freq, fdbk) = (+ : de.sdelay(nmax, int(ma.SR / freq), nsamp)) ~ (*(fdbk));
    };


//-------`(ho.)synDelay`----------
// Spatial ambisonic delay in syn mode.
//
// `synDelay` generates spatial components in ambisonics from one mono signal thanks to ambisonic delay.
// The delay time is defined for each spatial component among P=2\*n+1 at the ambisonic order `N`.
//
//
// #### Usage
//
// ```
// _ : synDelay(N, ld, wf, lf) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `ld`: list of delay time (in sample)
// * `wf`: window frequency (in Hz) for the overlapped delay
// * `lf`: list of feedback amont
//-----------------------------
synDelay(N, ld, wf, lf) = _ <: si.bus(2*N+1) : fxDelay(N, ld, wf, lf);


//-------`(ho.)fxGain`----------
// Gain controller for ambisonic component in fx mode.
//
// `fxGain` applies a gain to spatial components already created.
// The gain is defined for each spatial component among P=2\*n+1 at the ambisonic order `N`.
//
//
// #### Usage
//
// ```
// _,_, ... : fxGain(N, lg) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `lg`: list of gains
//-----------------------------
fxGain(N, lg) = par(i, 2*N+1, (_ * ba.take(i+1, lg)));

//-------`(ho.)synGain`----------
// Gain controller for ambisonic component in syn mode.
//
// `fxGain` generates spatial components in ambisonics from one mono signal.
// The gain is defined for each spatial component among P=2\*n+1 at the ambisonic order `N`.
//
//
// #### Usage
//
// ```
// _ : synGain(N, lg) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `lg`: list of gains
//-----------------------------
synGain(N, lg) = _ <: si.bus(2*N+1) : fxGain(N, lg);

//TYPES OF DISTRIBUTIONS: 22 EASING FUNCTIONS FROM [0, 1] to [0,1]
//(i+1)/p belongs to [0, 1] and its image by any function in the list also belongs to the interval

th(0, i, p) = (i+1) / p;
th(1, i, p) = ((i+1) / p)^2;
th(2, i, p) = sin(ma.PI * 0.5 * (i+1) / p);
th(3, i, p) = log10(1 + (i+1) / p) / log10(2);
th(4, i, p) = sqrt((i+1) / p);
th(5, i, p) = 1 - cos(ma.PI * 0.5 * (i+1) / p);
th(6, i, p) = (1 - cos(ma.PI * (i+1) / p)) * 0.5;
th(7, i, p) = 1 - (1 - (i+1) / p )^2;
th(8, i, p) = ((i+1) / p < 0.5) * 2 * ((i+1) / p)^2 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^2 * 0.5);
th(9, i, p) = ((i+1) / p)^3;
th(10, i, p) = 1 - (1 - (i+1) / p)^3;
th(11, i, p) = ((i+1) / p < 0.5) * 4 * ((i+1) / p)^3 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^3 * 0.5);
th(12, i, p) = ((i+1) / p)^4;
th(13, i, p) = 1 - (1 - (i+1) / p)^4;
th(14, i, p) = ((i+1) / p < 0.5) * 8 * ((i+1) / p)^4 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^4 * 0.5);
th(15, i, p) = ((i+1) / p)^5;
th(16, i, p) = 1 - (1 - (i+1) / p)^5;
th(17, i, p) = ((i+1) / p < 0.5) * 16 * ((i+1) / p)^5 + ((i+1) / p >= 0.5) * (1 - (-2 * (i+1) / p + 2)^5 * 0.5);
th(18, i, p) = 2^(10 * (i+1) / p - 10);
th(19, i, p) = ((i+1) / p < 1) * (1 - 2^(-10 * (i+1) / p)) + ((i+1) / p == 1);
th(20, i, p) = 1 - sqrt(1 - ((i+1) / p)^2);
th(21, i, p) = sqrt(1 - ((i+1) / p - 1)^2);


//========================================================================================
//==================================3D Functions==========================================
//========================================================================================
//========================================================================================

//=============================3D Encoding Functions======================================
//========================================================================================

//----------------------`(ho.)encoder3D`---------------------------------
// Ambisonic encoder. Encodes a signal in the spherical harmonics domain
// depending on an order of decomposition, an angle and an elevation. This decoder uses 
// SN3D norm and ACN channel ordering
//
// #### Usage
//
// ```
// encoder3D(N, x, a, e) : _
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `x`: the signal
// * `a`: the angle
// * `e`: the elevation
//----------------------------------------------------------------
encoder3D(N, x, theta, phi) = par(i, (N+1) * (N+1), x * y(degree(i), order(i), theta, phi))
with {
    // The degree l of the harmonic[l, m]
    degree(index) = int(sqrt(index));
    // The order m of the harmonic[l, m]
    order(index) = int(index - int(degree(index) * int(degree(index) + 1)));

    // The spherical harmonics
    //y(l, m, theta, phi) =  e(m, theta2) * k(l, m) * p(l, m, cos(phi + ma.PI * 0.5))
    y(l, m, theta, phi) =  cordon_coef(m) * e(m, theta2) * k(l, m) * p(l, m, sin(phi))
    with {
        cordon_coef(m) = -1^abs(m);
        //theta2 enables a continuous movement of elevation (when phi becomes greater than Pi/2)
        theta2 = theta + (1 - int(fmod(fmod(phi / ma.PI - 0.5, 2) + 2, 2))) * ma.PI;
        //
        // The associated Legendre polynomial
        // If l = 0   => p = 1
        // If l = m   => p = -1 * (2 * (l-1) + 1) * sqrt(1 - cphi*cphi) * p(l-1, l-1, cphi)
        // If l = m+1 => p = phi * (2 * (l-1) + 1) * p(l-1, l-1, cphi)
        // Else => p = (cphi * (2 * (l-1) + 1) * p(l-1, abs(m), cphi) - ((l-1) + abs(m)) * p(l-2, abs(m), cphi)) / ((l-1) - abs(m) + 1)
        p(l, m, cphi) = pcalcul(((l != 0) & (l == abs(m))) + ((l != 0) & (l == abs(m)+1)) * 2 + ((l != 0) & (l != abs(m)) & (l != abs(m)+1)) * 3, l, m, cphi)
        with {
            pcalcul(0, l, m, cphi) = 1;
            pcalcul(1, l, m, cphi) = -1 * (2 * (l-1) + 1) * sqrt(1 - cphi*cphi) * p(l-1, l-1, cphi);
            pcalcul(2, l, m, cphi) = cphi * (2 * (l-1) + 1) * p(l-1, l-1, cphi);
            pcalcul(s, l, m, cphi) = (cphi * (2 * (l-1) + 1) * p(l-1, abs(m), cphi) - ((l-1) + abs(m)) * p(l-2, abs(m), cphi)) / ((l-1) - abs(m) + 1);
        };

        // The exponential imaginary
        // If m > 0 => e^i*m*theta = cos(m * theta)
        // If m < 0 => e^i*m*theta = sin(-m * theta)
        // If m = 0 => e^i*m*theta = 1
        e(m, theta) = ecalcul((m > 0) * 2 + (m < 0), m, theta)
        with {
            ecalcul(2, m, theta) = cos(m * theta);
            ecalcul(1, m, theta) = sin(abs(m) * theta);
            ecalcul(s, m, theta) = 1;
        }; 
        
        // The normalization
        // If m  = 0 => k(l, m) = 1
        // If m != 0 => k(l, m) = sqrt((l - abs(m))! / l + abs(m))!) * sqrt(2)
        k(l, m) = kcalcul((m != 0), l, m)
        with {
            kcalcul(0, l, m) = 1;
            kcalcul(1, l, m) = sqrt(2) / sqrtFactQuotient(l+abs(m), l-abs(m))
            with {
                //factorial quotient fq(n, p)=n! / p! = n(n-1)...(p+1) when n > p
                //enables factor simplification
                //and considering the square root of a product as a product of square roots
                sqrtFactQuotient(n, p) = sqrtProd(n-p, p)
                with {
                    //sqrtProd(n, p) computes the product sqrt(p+1) x sqrt(p+2) x ... x sqrt(n)
                    //to enable factorial quotient simplification
                    sqrtProd(1, p) = sqrt(p+1);
                    sqrtProd(n, p) = sqrt(p+n) * sqrtProd(n-1, p);
                };
            };
        };
    };
};


//-------`(ho.)rEncoder3D`----------
// Ambisonic encoder in 3D including source rotation. A mono signal is encoded at at certain ambisonic order
// with two possible modes: either rotation with 2 angular speeds (azimuth and elevation), or static with a fixed pair of angles.
//
// `rEncoder3D` is a standard Faust function.
//
// #### Usage
//
// ```
// _ : rEncoder3D(N, azsp, elsp, az, el, it) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `azsp`: the azimuth speed expressed as angular speed (2PI/sec), positive or negative
// * `elsp`: the elevation speed expressed as angular speed (2PI/sec), positive or negative
// * `az`: the fixed azimuth when the azimuth rotation stops (azsp = 0) in radians
// * `el`: the fixed elevation when the elevation rotation stops (elsp = 0) in radians
// * `it` : interpolation time (in milliseconds) between the rotation and the fixed modes
//-----------------------------
rEncoder3D(N, azsp, elsp, az, el, it) = this3DEncoder
with {
    basic3DEncoder(sig, ang1, ang2) = encoder3D(N, sig, ang1, ang2);
    this3DEncoder = (_, rotationOrStaticAzim, rotationOrStaticElev) : basic3DEncoder
    with {
        x1 = (os.phasor(1, azsp), az, 1) : (+, _) : fmod : *(2 * ma.PI);
        vn1 = (azsp == 0) : si.smooth(ba.tau2pole(it));
        rotationOrStaticAzim = (1-vn1) * x1 + vn1 * az;
        x2 = (os.phasor(1, elsp), el, 1) : (+, _) : fmod : *(2 * ma.PI);
        vn2 = (elsp == 0) : si.smooth(ba.tau2pole(it));
        rotationOrStaticElev =  (1-vn2) * x2 + vn2 * el;
    };
};


//-------`(ho.)aleaEncoder3D`----------
// Ambisonic aleatory encoder in 3D. A mono signal is encoded at an ambisonic order
// with a random position of the source around an azimuth and an elevation inside an azimuth range and an elevation range.
//
// #### Usage
//
// ```
// _ : aleaEncoder3D(N, freq, azimuth, elevation, deltaAzimuth, deltaElevation, indA, indE) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `freq`: the frequency in Herz of update of the random position of the source
// * `azimuth`: the azimuth in degrees on which the source is centered
// * `elevation`: the elevation in degrees on which the source is centered
// * `deltaAzimuth` : the range of azimuth variation of the source in degrees
// * `deltaElevation` : the range of elevation variation of the source in degrees
// * `indA` : the index of the random azimuth generator, used when there are several random decoders, but can be left to 0 when there is only one.
// * `indE` : the index of the random elevation generator, used when there are several random decoders, but can be left to 1 when there is only one.
//-----------------------------
aleaEncoder3D(N, freq, azimuth, elevation, deltaAzimuth, deltaElevation, indA, indE) = thisAleaEncoder3D
		with {
			ramp = os.phasor(1, freq);
			th = (ramp > 0.001) * (ramp@1 <= 0.001);
			temporalFilter = ba.sAndH(th);
			//computes the temporal interval taking into account the case when f=0 and when f<0
			dt = (ma.SR, max(0.00001, freq)) : / : ma.fabs ;
			rndValA = + (90000 + indA * 20) ~ *(1410065407);
            rndValE = + (90000 + indE * 20) ~ *(1410065407);
			noiseValA = rndValA / 2147483647.0;
            noiseValE = rndValE / 2147483647.0;
			randomAzimuth = noiseValA : *(deltaAzimuth / 2) : +(azimuth) : temporalFilter : ba.line(dt) : *(ma.PI) : /(180);
            randomElevation = noiseValE : *(deltaElevation / 2) : +(elevation) : temporalFilter : ba.line(dt) : *(ma.PI) : /(180);
            basic3DEncoder(sig, ang1, ang2) = ho.encoder3D(N, sig, ang1, ang2);
            thisAleaEncoder3D = (_, randomAzimuth, randomElevation) : basic3DEncoder;
};


//-------`(ho.)multiEncoder3D`----------
// 3D Encoding of a set of P signals distributed on the unit sphere according to lists of azimuth and elevation lists of speeds and angles
//
// #### Usage
//
// ```
// _,_, ... : multiEncoder(N, lspeed, langle, it) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `lAzSpeed` : a list of azimuth speeds in turns by second (one speed per input signal, positive or negative)
// * `lElSpeed` : a list of elevation speeds in turns by second (one speed per input signal, positive or negative)
// * `lAz` : a list of azimuth angles in radians on the unit circle to localize the sources (one angle per input signal) when their azimuth speed is 0
// * `lEl` : a list of elevation angles in radians on the unit circle to localize the sources (one angle per input signal) when their elevation speed is 0
// * `it` : interpolation time (in milliseconds) between the rotation and the fixed modes.
//-----------------------------
multiEncoder3D(N, lAzSpeed, lElSpeed, lAz, lEl, it) = par(i, P, ho.rEncoder3D(N, ba.take(i+1, lAzSpeed), ba.take(i+1, lElSpeed), ba.take(i+1, lAz), ba.take(i+1, lEl), it)) :> si.bus((N+1)*(N+1))
with {
    P = outputs(lAzSpeed); //all lists are supposed to have the same length
};


//-------`(ho.)multiAleaEncoder3D`----------
// 3D aleatory encoding of a set of P signals.
// The signals are distributed on the unit sphere.
// Each of them is centered around an azimuth and an elevation,
// within an azimuth range, an elevation range, and updated at certain frequencies.
//
// #### Usage
//
// ```
// _,_, ... : multiAleaEncoder(N, lFreq, lAngle, lDeltaAngle) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `lFreq` : a list of frequencies in Herz of update of the random position of each source
// * `lAz` : a list of azimuths in degrees on which each source is centered
// * `lEl` : a list of elevations in degrees on which each source is centered
// * `lDeltaAz` : a list of ranges of azimuth variation of each source in degrees
// * `lDeltaEl` : a list of ranges of elevation variation of each source in degrees
//-----------------------------
multiAleaEncoder3D(N, lFreq, lAz, lEl, lDeltaAz, lDeltaEl) = par(i, P, aleaEncoder3D(N, ba.take(i+1, lFreq), ba.take(i+1, lAz), ba.take(i+1, lEl), ba.take(i+1, lDeltaAz), ba.take(i+1, lDeltaEl), 2*i, 2*i+1)) :> si.bus((N+1)*(N+1))
with {
    P = outputs(lFreq); //all lists are supposed to have the same length
};

//----------------------`(ho.)decoder3D`---------------------------------
// Regular ambisonic 3D decoder. Decodes an ambisonics sound field for a spherical
// array of loudspeakers using a direct decoding technic. This decoder uses 
// SN3D norm and ACN channel ordering. The lenght of the list determines the 
// number of loudspeakers. 
//
// #### Usage
//
// ```
// decoder3D(N, la, le) : _,_,...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `la`: the list of loudspeaker azimut
// * `le`: the list of loudspeaker elevation
//----------------------------------------------------------------
decoder3D(N, la, le) = par(i, (N+1)^2, _) <: par(i, P, speaker(N, azim(i), elev(i))) 
with {
    P = outputs(la);
    azim(i) = ba.take(i+1, la) * ma.PI / 180. ; 
    elev(i) = ba.take(i+1, le) * ma.PI / 180. ; 
    speaker(N,theta,phi) = _/(2), si.bus(((N+1)^2)-1), ho.encoder3D(N, 2/P, theta, phi) : si.dot((N+1)^2);
};


//=========================3D Optimization Functions======================================
// Functions to weight the circular harmonics signals depending on the ambisonic optimization.
// It can be `basic`for no optimization, `maxRe` or `inPhase`.
//========================================================================================

//----------------`(ho.)optimBasic3D`-------------------------
// The basic optimization has no effect and should be used for a perfect
// sphere of loudspeakers with one listener at the perfect center loudspeakers
// array.
//
// #### Usage
//
// ```
// _,_, ... : optimBasic3D(N) : _,_, ... 
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
//-----------------------------------------------------
optimBasic3D(N) = par(i, (N+1) * (N+1), _);


//----------------`(ho.)optimMaxRe3D`-------------------------
// The maxRe optimization optimize energy vector. It should be used for an
// auditory confined in the center of the loudspeakers array.
//
// #### Usage
//
// ```
// _,_, ... : optimMaxRe3D(N) : _,_, ... 
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
//-----------------------------------------------------
optimMaxRe3D(N) = par(i, (N+1) * (N+1), MaxRe(N, degree(i), _))
with {
    // The degree l of the harmonic[l, m]
    degree(index)  = int(sqrt(index));
    MaxRe(N, l, _)= _ * cos(l / (2*N+2) * ma.PI);
};


//----------------`(ho.)optimInPhase3D`-------------------------
// The inPhase Optimization optimizes energy vector and put all loudspeakers signals
// in phase. It should be used for an auditory.
//
// #### Usage
//
// ```
// _,_, ... : optimInPhase3D(N) : _,_, ... 
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
//-----------------------------------------------------
optimInPhase3D(N) = par(i, (N+1) * (N+1), InPhase(N, degree(i), _))
with {
    // The degree l of the harmonic[l, m]
    degree(index)  = int(sqrt(index));
    InPhase(N, l, _)= _ * (fact(N) * fact(N)) / (fact(N - l) * fact(N + l))
    with {
        fact(0) = 1;
        fact(n) = n * fact(n-1);
    };
};


//-------`(ho.)optim3D`----------
// Ambisonic optimizer including the three elementary optimizers:
// `(ho).optimBasic3D`, `(ho).optimMaxRe3D` and `(ho.)optimInPhase3D`.
//
// #### Usage
//
// ```
// _,_, ... : optim3D(N, ot) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `ot` : optimization type (0 for optimBasic, 1 for optimMaxRe, 2 for optimInPhase)
//-----------------------------
optim3D(N, ot) = thisOptimizer
with {
    optb = (ot == 0) : si.smoo;
    optm = (ot == 1) : si.smoo;
    opti = (ot == 2) : si.smoo;
    bus3D = si.bus((N+1)*(N+1));
    thisOptimizer = ((bus3D  <: ((bus3D:ho.optimBasic3D(N)), (bus3D:ho.optimMaxRe3D(N)), (bus3D:ho.optimInPhase3D(N)))), ((optb <: bus3D), (optm <: bus3D), (opti <: bus3D))) : ro.interleave(3*(N+1)*(N+1), 2) : par(i, 3*(N+1)*(N+1), *) :> bus3D;
};


//-------`(ho.)vectorVE3D`----------
// The velocity vector is valid for frequencies below 700 Hz, its direction corresponds 
//to the apparent direction of the source and its norm corresponds to the precision (or blur) 
//of the rendering. The energy vector is the analog of the velocity vector for frequencies 
//from 500 Hz to 5 kHz. These localization indices, calculated on the signals sent to the loudspeakers, 
//enable ambisonic signals to be optimized for the best possible rendering in a given situation. 
//The function receives post-decodage signals and gives the cartesian coordinate of the two vectors.
//
// #### Usage
//
// ```
// _,_, ... : vectorVE3D(laz, lel) : _,_,_,_,_,_
// ```
//
// Where:
//
// * `laz`: the list of azimuth in degrees
// * `lel`: the list of elevation in degrees
//-----------------------------
vectorVE3D(laz, lel) = thisVectorVE3D
with{
    p = outputs(laz);
    azim(i) = ba.take(i+1, laz);
    elev(i) = ba.take(i+1, lel);
    //Polar to cartesian coordinates
    lx(p) = par(i, p, * (cos((azim(i) + 90) / 180 * ma.PI)));
    ly(p) = par(i, p, * (sin((azim(i) + 90) / 180 * ma.PI)));
    lz(p) = par(i, p, * (cos((elev(i) + 90) / 180 * ma.PI)));
    
    clip(mini,maxi) = min(maxi, max(mini, _));
    parSquare(p) = par(i, p, ^(2));
    sumOfSquare(p) = par(i, p, _ <: (*)) :> _ ;
    simpleSum(p) = si.bus(p) :> _ ;
    zeroException =  _ <: (_ == (0)) * ma.MIN, _  : + ;

    vx(p) = si.bus(2*p+2) : par(i, 2, (lx(p):simpleSum(p))), si.bus(2):route(4,4, 1, 1, 2, 3, 3, 4, 4, 2) : /, / : clip(-1, 1), clip(-1,1);
    vy(p) = si.bus(2*p+2) : par(i, 2, (ly(p):simpleSum(p))), si.bus(2):route(4,4, 1, 1, 2, 3, 3, 4, 4, 2) : /, / : clip(-1, 1), clip(-1,1);
    vz(p) = si.bus(2*p+2) : par(i, 2, (lz(p):simpleSum(p))), si.bus(2):route(4,4, 1, 1, 2, 3, 3, 4, 4, 2) : /, / : clip(-1, 1), clip(-1,1);

thisVectorVE3D = si.bus(p) <: si.bus(p), (parSquare(p)<:si.bus(p), (simpleSum(p):zeroException)), (simpleSum(p):zeroException) <: vx(p), vy(p), vz(p) : route(6,6, 1, 1, 2, 4, 3, 2, 4, 5, 5, 3, 6, 6);
};


//-------`(ho.)fxDecorrelation3D`----------
// Spatial ambisonic decorrelation in fx mode.
//
// `fxDecorrelation3D` applies decorrelations to spatial components already created.
// The decorrelation is defined for each #i spatial component among P=(N+1)^2 in 3D as a delay of 0 
// if factor `fa` is under a certain value 1-(i+1)/P and d\*F((i+1)/p) in the contrary case,
// where `d` is the maximum delay applied (in samples) and F is a distribution function for durations.
// The user can choose this delay time distribution among 22 different ones.
// The delay increases according to the index of ambisonic components.
// But it increases at each step and it is modulated by a threshold.
// For the 3D decorrelation, the user can choose the increment order among 3 different ones. 
// Therefore, delays are progressively revealed when the factor increases:
//
// * when the factor is close to 0, only upper components are delayed;
// * when the factor increases, more and more components are delayed.
//
//
//H mode 0  H mode 1  H mode 2             THRESHOLD            DELAY
//0         0         0                    1-(1/P)              0 OR DELAY*F(1/P)
//-1, 1     0, 1     -1, 1                 1-(2/P)              0 OR DELAY*F(2/P)
//0, 1     -1, 1      1, 1                 1-(3/P)              0 OR DELAY*F(3/P) 
//1, 1      1, 1      0, 1                 1-(4/P)              0 OR DELAY*F(4/P)
//-2, 2     0, 2     -2, 2                 1-(5/P)              0 OR DELAY*F(5/P)
//-1, 2    -1, 2      2, 2                 1-(6/P)              0 OR DELAY*F(6/P)
//0, 2      1, 2     -1, 2                 1-(7/P)              0 OR DELAY*F(7/P)
//1, 2     -2, 2      1, 2                 1-(8/P)              0 OR DELAY*F(8/P)
//2, 2      2, 2      0, 2                 1-(9/P)              0 OR DELAY*F(9/P)
//...
//
// #### Usage
//
// ```
// _,_, ... : fxDecorrelation3D(N, d, wf, fa, fd, tf, md) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `d`: the maximum delay applied (in samples)
// * `wf`: window frequency (in Hz) for the overlapped delay
// * `fa`: decorrelation factor (between 0 and 1)
// * `fd`: feedback / level of reinjection (between 0 and 1)
// * `tf`: type of function of delay distribution (integer, between 0 and 21)
// * `md`: type of distribution ordering (integer between 0 and 2)
//-----------------------------
fxDecorrelation3D(N, d, wf, fa, fd, tf, mode) = par(i, N+1, par(j, 2*i+1,fdOverlappedDelay(dur(d, i, j, (N+1)^2, fa, tf, mode), 262144, wf, fd, fa, i, j, (N+1)^2, mode)))
with {
    //
    fdOverlappedDelay(nsamp, nmax, freq, fdbk, fa, i, j, p, mode) = (+ : de.sdelay(nmax, int(ma.SR / freq), nsamp)) ~ ( * (fdbk * fa * env(fa, index(mode, i, j), p)));
    //
    //actives the feedback amount when the factor is upper the threshold of the spatial component
    env(fa, k, p) = (fa > ((p-k-1)/p)) : si.smooth(ba.tau2pole(0.005));
    //
    //computes the ith duration of the ith delay in samples with twenty two possibilities of distribution in three types of channel ordering
    elemdur(d, i, j, p, fa, tf, ind, ind2, mode) = (mode == ind2) * (tf == ind) * (fa > (1 - x)) * d * x * fa
    with {
        x = th(ind, index(ind2, i, j), p);
    };
    //duration in samples computed as a sum of the 66 cases, the twenty two possibilities of distribution and the three types of channel ordering//
    dur(d, i, j, p, fa, tf, mode) = sum(ind2, 3, sum(ind, 22, elemdur(d, i, j, p, fa, tf, ind, ind2, mode))) : int;
};


//-------`(ho.)synDecorrelation3D`----------
// Spatial ambisonic decorrelation in syn mode.
//
// `synDecorrelation3D` creates decorrelated spatial components from one mono source.
// The decorrelation is defined for each #i spatial component among P=(N+1)^2 in 3D as a delay of 0 
// if factor `fa` is under a certain value 1-(i+1)/P and d\*F((i+1)/p) in the contrary case,
// where `d` is the maximum delay applied (in samples) and F is a distribution function for durations.
// The user can choose this delay time distribution among 22 different ones.
// The delay increases according to the index of ambisonic components.
// But it increases at each step and it is modulated by a threshold.
// For the 2D decorrelation, the increment order follows the Ambisonics Channel Number. 
// For the 3D decorrelation, the user can choose the increment order among 3 different ones. 
// Therefore, delays are progressively revealed when the factor increases:
//
// * when the factor is close to 0, only upper components are delayed;
// * when the factor increases, more and more components are delayed.
//
//H mode 0  H mode 1  H mode 2             THRESHOLD            DELAY
//0         0         0                    1-(1/P)              0 OR DELAY*F(1/P)
//-1, 1     0, 1     -1, 1                 1-(2/P)              0 OR DELAY*F(2/P)
//0, 1     -1, 1      1, 1                 1-(3/P)              0 OR DELAY*F(3/P) 
//1, 1      1, 1      0, 1                 1-(4/P)              0 OR DELAY*F(4/P)
//-2, 2     0, 2     -2, 2                 1-(5/P)              0 OR DELAY*F(5/P)
//-1, 2    -1, 2      2, 2                 1-(6/P)              0 OR DELAY*F(6/P)
//0, 2      1, 2     -1, 2                 1-(7/P)              0 OR DELAY*F(7/P)
//1, 2     -2, 2      1, 2                 1-(8/P)              0 OR DELAY*F(8/P)
//2, 2      2, 2      0, 2                 1-(9/P)              0 OR DELAY*F(9/P)
//...
//
// #### Usage
//
// ```
// _ : synDecorrelation3dD(N, d, wf, fa, fd, tf, md) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `d`: the maximum delay applied (in samples)
// * `wf`: window frequency (in Hz) for the overlapped delay
// * `fa`: decorrelation factor (between 0 and 1)
// * `fd`: feedback / level of reinjection (between 0 and 1)
// * `tf`: type of function of delay distribution (integer, between 0 and 21)
// * `md`: type of distribution ordering (integer between 0 and 2)
//-----------------------------
synDecorrelation3D(N, d, wf, fa, fd, tf, mode) = _ <: fxDecorrelation3D(N, d, wf, fa, fd, tf, mode); 


//-------`(ho.)fxRingMod3D`----------
// Spatial ring modulation in fx mode.
//
// `fxRingMod3D` applies ring modulation to spatial components already created.
// The ring modulation is defined for each spatial component among P=(N+1)^2 at the ambisonic order `N` in 3D.
// For each spatial component #i, the result is either the original signal or a ring modulated signal
// according to a threshold that is i/P.
//
// The general process is drive by a factor `fa` between 0 and 1 and a modulation frequency `f0`.
// If `fa` is greater than theshold (P-i-1)/P, the ith ring modulator is on with carrier frequency of f0\*(i+1)/P.
// On the contrary, it provides the original signal.
//
//
//H mode 0  H mode 1  H mode 2             THRESHOLD            FREQUENCY
//0         0         0                    1-(1/P)              ORIGINAL OR RING MODULATION BY F0*F(1/P)
//-1, 1     0, 1     -1, 1                 1-(2/P)              ORIGINAL OR RING MODULATION BY F0*F(2/P)
//0, 1     -1, 1      1, 1                 1-(3/P)              ORIGINAL OR RING MODULATION BY F0*F(3/P) 
//1, 1      1, 1      0, 1                 1-(4/P)              ORIGINAL OR RING MODULATION BY F0*F(4/P)
//-2, 2     0, 2     -2, 2                 1-(5/P)              ORIGINAL OR RING MODULATION BY F0*F(5/P)
//-1, 2    -1, 2      2, 2                 1-(6/P)              ORIGINAL OR RING MODULATION BY F0*F(6/P)
//0, 2      1, 2     -1, 2                 1-(7/P)              ORIGINAL OR RING MODULATION BY F0*F(7/P)
//1, 2     -2, 2      1, 2                 1-(8/P)              ORIGINAL OR RING MODULATION BY F0*F(8/P)
//2, 2      2, 2      0, 2                 1-(9/P)              ORIGINAL OR RING MODULATION BY F0*F(9/P)
//...
//
// #### Usage
//
// ```
// _,_, ... : fxRingMod3D(N, f0, fa, tf, md) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `f0`: the maximum frequency of modulation applied (in Hz)
// * `fa`: modulation factor (between 0 and 1)
// * `tf`: type of function of modulation distribution (integer, between 0 and 21)
// * `md`: type of distribution ordering (integer between 0 and 2)
//-----------------------------

fxRingMod3D(N, f0, fa, tf, mode) = par(i, N+1, par(j, 2*i+1, gate_ringmod(f0, mode, i, j, (N+1)^2, fa, tf)))
with {
    //
    env1(fa, mode, i, j, P) = (fa > ((P-index(mode, i, j)-1)/P)) : si.smooth(ba.tau2pole(0.005));
    env1c(fa, mode, i, j, P) = 1 - env1(fa, mode, i, j, P);
    //
    gate_ringmod(f, mode, i, j, P, fa, tf) = _ <: _ * os.osccos(freq(f, mode, i, j, P, tf)) * env1(fa, mode, i, j, P), _ * env1c(fa, mode, i, j, P) : +;
    //
    ringmodfreq(f, mode, i, j, P, tf, ind, ind2) = (mode == ind2) * (tf == ind) * f * x * coef
    with {
        x = th(ind, index(ind2, i, j), P);
        coef = min(1, max(P * (fa - (P - index(ind2, i, j) - 1) / P), 0));
    };
    //
    freq(f, mode, i, j, P, tf) = sum(ind2, 3, sum(ind, 22, ringmodfreq(f, mode, i, j, P, tf, ind, ind2)));
};


//-------`(ho.)synRingMod3D`----------
// Spatial ring modulation in syn mode.
//
// `synRingMod3D` generates modulated spatial components from one mono source.
// The ring modulation is defined for each spatial component among P=(N+1)^2 at the ambisonic order `N` in 3D.
// For each spatial component #i, the result is either the original signal or a ring modulated signal
// according to a threshold that is i/P.
//
// The general process is drive by a factor `fa` between 0 and 1 and a modulation frequency `f0`.
// If `fa` is greater than theshold (P-i-1)/P, the ith ring modulator is on with carrier frequency of f0\*(i+1)/P.
// On the contrary, it provides the original signal.
//
//
//H mode 0  H mode 1  H mode 2             THRESHOLD            FREQUENCY
//0         0         0                    1-(1/P)              ORIGINAL OR RING MODULATION BY F0*F(1/P)
//-1, 1     0, 1     -1, 1                 1-(2/P)              ORIGINAL OR RING MODULATION BY F0*F(2/P)
//0, 1     -1, 1      1, 1                 1-(3/P)              ORIGINAL OR RING MODULATION BY F0*F(3/P) 
//1, 1      1, 1      0, 1                 1-(4/P)              ORIGINAL OR RING MODULATION BY F0*F(4/P)
//-2, 2     0, 2     -2, 2                 1-(5/P)              ORIGINAL OR RING MODULATION BY F0*F(5/P)
//-1, 2    -1, 2      2, 2                 1-(6/P)              ORIGINAL OR RING MODULATION BY F0*F(6/P)
//0, 2      1, 2     -1, 2                 1-(7/P)              ORIGINAL OR RING MODULATION BY F0*F(7/P)
//1, 2     -2, 2      1, 2                 1-(8/P)              ORIGINAL OR RING MODULATION BY F0*F(8/P)
//2, 2      2, 2      0, 2                 1-(9/P)              ORIGINAL OR RING MODULATION BY F0*F(9/P)
//...
//
// #### Usage
//
// ```
// _ : synRingMod3D(N, f0, fa, tf, md) : _,_, ...
// ```
//
// Where:
//
// * `N`: the ambisonic order (constant numerical expression)
// * `f0`: the maximum frequency of modulation applied (in Hz)
// * `fa`: modulation factor (between 0 and 1)
// * `tf`: type of function of modulation distribution (integer, between 0 and 21)
// * `md`: type of distribution ordering (integer between 0 and 2)
//-----------------------------
synRingMod3D(N, f0, fa, tf, mode) = _ <: fxRingMod3D(N, f0, fa, tf, mode);


//MODES OF SPATIAL COMPONENT SORTING
//computes index of the ith spatial component function of channel ordering type
//H mode 0  H mode 1  H mode 2
//0         0         0   
//-1, 1     0, 1     -1, 1
//0, 1     -1, 1      1, 1
//1, 1      1, 1      0, 1
//-2, 2     0, 2     -2, 2
//-1, 2    -1, 2      2, 2
//0, 2      1, 2     -1, 2
//1, 2     -2, 2      1, 2
//2, 2      2, 2      0, 2
index(mode, x, y) = (mode==0) * (x^2 + y) + (mode==1) * ((y <= x) * (x^2 + 2 * y) + (y > x) * lastMinus1or2(x, y)) + (mode==2) * ((x != 0) * (((y < x) * lastMinus2(x, y)) + (y >= x) * lastPlus2(x, y))) 
with {
    
lastMinus1or2(x, y) = x^2 + 2 * (y - (y - x)) - (2 * (y - x) - 1);
lastMinus2(x, y) = x^2 + x + (x-1) - 2 * y;
lastPlus2(x, y) = x^2 + 2 * (y - x);

};